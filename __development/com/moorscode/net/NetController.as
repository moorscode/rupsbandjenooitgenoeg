package com.moorscode.net {	import flash.net.XMLSocket;	import flash.events.*;	import flash.utils.Timer;	import flash.utils.getTimer;	public class NetController {		private static var xmlSocket:XMLSocket = new XMLSocket();				private static var server:String = "";		private static var port:int = 0;				private static var sendQueue:Array = new Array();		private static var sendQueueTimer:Timer;				private static var doPings:Boolean = false;		public 	static var ping:uint = 0;		private static var pingTime:uint = 0;		private static var pingDelaySeconds:uint = 1;		private static var pingTimer:Timer;				private static var keepAliveDelay:uint = 30; // send ping even 30 seconds to see if the connection is alive.		private static var keepAliveTimer:Timer;					private static var initialized:Boolean = false;				private static var dispatcher:EventDispatcher = new EventDispatcher();				private static var retryCount:uint = 0;		public 	static var retryLimit:uint = 5;		public 	static var retryDelay:uint = 5000;		private static var retryTimer:Timer;				private static var connecting:Boolean = false;				public function NetController():void {		}				public static function initialize():void {			xmlSocket.addEventListener(DataEvent.DATA, parseData);			xmlSocket.addEventListener(Event.CONNECT, socketEvent);			xmlSocket.addEventListener(Event.CLOSE, socketEvent);			xmlSocket.addEventListener(IOErrorEvent.IO_ERROR, socketEvent);			xmlSocket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, socketEvent);						initialized = true;		}				public static function connect(server:String, port:int = 4041, doPings:Boolean = false):void {			if(!initialized) initialize();						NetController.doPings = doPings;						// trace('Connecting to: ' + server + ':' + port);						NetController.server = server;			NetController.port = port;						if(xmlSocket.connected || connecting) {				// already connected or trying to connect - don't allow any extra connections				return;			}						connecting = true;						xmlSocket.timeout = retryDelay - 1; // x milli-seconds before unable to connect.			xmlSocket.connect(server, port);		}				public static function push(data:String):void {			if(xmlSocket.connected) {				xmlSocket.send(data);			} else {				sendQueue.push(data);			}		}				// NET - Send XML to Server (queued or not)		public static function send(xml:XML, forceNoDelay:Boolean = false):void {			if(!xmlSocket.connected) {				sendQueue.push(xml);				return;			}						// using the sendQueue keeps from spamming the server:			if(forceNoDelay) {				/// trace("NetController [direct]: Sending " + xml);				xmlSocket.send(xml);			} else {				sendQueue.push(xml);			}		}				private static function handleSendQueue(event:TimerEvent):void {			if(sendQueue.length == 0) return;									if(xmlSocket.connected) {				// trace("NetController [queue]: Sending " + sendQueue[0]);				xmlSocket.send(sendQueue[0]);				sendQueue.shift();			} else {				sendQueue = new Array();			}		}				public static function enablePing(value:Boolean = true):void {			doPings = value;			if(doPings) doPing();		}				private static function doPing(event:TimerEvent = null):void {			if(event && !doPings && event.target == pingTimer) return;						if(xmlSocket.connected) {				pingTime = getTimer();				xmlSocket.send("PING");			} else {				ping = 0;			}		}				private static function parseData(event:DataEvent):void {			// trace("NetController: Recieved " + event.data);						if(event.data == "PONG") {				ping = getTimer() - pingTime;				dispatcher.dispatchEvent(new NetEvent(NetEvent.PING));				return;			}						if(event.data == "CONNECTED") {				dispatcher.dispatchEvent(new NetEvent(NetEvent.CONNECT));				return;			}						var xmlData:XML = new XML(event.data);			var dataEvent:NetEvent = new NetEvent(NetEvent.DATA);			dataEvent.xml = xmlData;						dispatcher.dispatchEvent(dataEvent);		}				public static function get connected():Boolean {			return xmlSocket.connected;		}				public static function forceReconnect(event:* = null):void {			if(xmlSocket.connected) {				xmlSocket.close();			}		}						// NET - Event Handler (Connect, Disconnect, IO / Security Error)		private static function socketEvent(event:Event):void {			switch(event.type) {				case Event.CONNECT:					if(retryTimer) {						if(retryTimer.running) {							retryTimer.stop();						}						retryTimer.removeEventListener(event.type, arguments.callee);						retryTimer = null;					}										connecting = false;										sendQueueTimer = new Timer(50);					sendQueueTimer.addEventListener(TimerEvent.TIMER, handleSendQueue);					sendQueueTimer.start();										pingTimer = new Timer(pingDelaySeconds * 1000);					pingTimer.addEventListener(TimerEvent.TIMER, doPing);					pingTimer.start();										doPing();										keepAliveTimer = new Timer(keepAliveDelay * 1000);					keepAliveTimer.addEventListener(TimerEvent.TIMER, doPing);					keepAliveTimer.start();										break;									case Event.CLOSE:					connecting = false;										if(pingTimer) {						if(pingTimer.running) {							pingTimer.stop();						}												pingTimer.removeEventListener(TimerEvent.TIMER, doPing);						pingTimer = null;					}										if(sendQueueTimer) {						if(sendQueueTimer.running) {							sendQueueTimer.stop();						}												sendQueueTimer.removeEventListener(TimerEvent.TIMER, handleSendQueue);						sendQueueTimer = null;					}										if(keepAliveTimer) {						if(keepAliveTimer.running) {							keepAliveTimer.stop();						}												keepAliveTimer.removeEventListener(TimerEvent.TIMER, doPing);						keepAliveTimer = null;					}										trace("Connection closed.");										dispatcher.dispatchEvent(new NetEvent(NetEvent.DISCONNECT));					sendQueue = new Array();									case IOErrorEvent.IO_ERROR:					// trace("Failed to connect: IO_ERROR");										if(!retryTimer && retryLimit > 1) {						retryCount = 0;						retryTimer = new Timer(retryDelay);						retryTimer.addEventListener(TimerEvent.TIMER, reconnect);						retryTimer.start();					}										reconnect();									case SecurityErrorEvent.SECURITY_ERROR:					if(event.type != Event.CLOSE) {						dispatcher.dispatchEvent(new NetEvent(NetEvent.ERROR));					}										break;			}		}				private static function reconnect(event:TimerEvent = null):void {			retryCount++;						if(retryCount >= retryLimit || xmlSocket.connected) {				retryTimer.stop();				retryTimer.removeEventListener(event.type, arguments.callee);				retryTimer = null;								trace('Giving up reconnecting after ' + retryCount + ' tries.');								return;			}						if(retryTimer == null) {				retryTimer = new Timer(retryDelay);				retryTimer.addEventListener(TimerEvent.TIMER, reconnect);				retryTimer.start();			}						trace('Reconnecting attempt #' + retryCount);						if(server != "") {				connect(server, port);			}		}				public static function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true) {			dispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);		}		public static function removeEventListener(type:String, listener:Function, useCapture:Boolean = false) {			dispatcher.removeEventListener(type, listener, useCapture);		}	}}
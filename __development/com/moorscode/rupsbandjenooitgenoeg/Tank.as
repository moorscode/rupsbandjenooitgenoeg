package com.moorscode.rupsbandjenooitgenoeg {	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.filters.BitmapFilter;    import flash.filters.BitmapFilterQuality;    import flash.filters.GlowFilter;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.media.SoundChannel;	import flash.utils.Timer;		import com.moorscode.game.IGameObject;	import com.moorscode.game.GameObjectEvent;	import com.moorscode.game.GameCamera;		import com.moorscode.sound.Audio;	import com.moorscode.input.Input;		import flash.filters.DropShadowFilter;		public class Tank extends IGameObject {		public	  var reloadTime:int = 2000;				protected var playerId:int = 0;				protected var unloading:Boolean = false;				protected var turretTurnSpeed:Number = 2;		protected var turretDirection:Number = 0;		protected var targetTurretDirection:Number = 0;				protected var body:Sprite;		protected var turret:Sprite;				protected var lastTarget:Point;				protected var maxTracks:Number = 15;				protected var lastVolume:Number;		protected var engineSound:SoundChannel;				private   var rank:uint = 0;		private   var glow:GlowFilter;				private   var reloadTimer:Timer;		private   var reloadResume:int = 0;		private   var reloadTimerStarted:Number = 0;		private   var canShoot:Boolean = true;				protected var travelDistance:int = 0;		protected var lastTravelDistance:int = 0;				private   var myTracks:Array = new Array();				public function Tank(position:Point = null, reloadTime:int = 2000, enemy:Boolean = false):void {			super(position);						var body:String = ((enemy)?"enemyT":"t") + "ankBody";			var top:String = ((enemy)?"enemyT":"t") + "ankTop";						this.body = Sprite(addChild(getSprite(body)));			this.turret = Sprite(addChild(getSprite(top)));						maxSpeed = 3;			minSpeed = -1.5;			slowdownSpeed = 0.97;									this.hasSound = true;						engineSound = Audio.playMusic("tank.mp3", true, 0.0);						lastTarget = position;						var shade:DropShadowFilter = new DropShadowFilter();				shade.angle = 45;				shade.blurX = shade.blurY = 2;				shade.distance = 2;				shade.alpha = 0.8;				shade.strength = 0.5;						this.turret.filters = [shade];						this.reloadTime = reloadTime;			reloadTimer = new Timer(this.reloadTime);			reloadTimer.addEventListener(TimerEvent.TIMER, releaseReloading);		}				override public function setPosition(position:Point):void {			super.setPosition(position);						if(lastTarget == null) {				lastTarget = position;			}		}				public function setRank(rank:uint = 0):void {			var rankColors:Array = [0xffffff, 0xfbd64b, 0x3e7ab1, 0xf1a8a7, 0x9b507c, 0xf3ae5b, 0xc77a51, 0x46a269, 0xa3b0b3, 0xd94c58, 0x312627];			this.rank = Math.min(10, Math.max(0, rank));						if(rank > 0) {				glow = new GlowFilter();				glow.blurX = glow.blurY = 6;				glow.inner = false;				glow.quality = BitmapFilterQuality.HIGH;				glow.color = rankColors[rank];								body.filters = [glow];			} else {				body.filters = new Array();			}		}				public function get turretRotation():Number {			return Math.floor(turretDirection * 100)/100;		}				public function set turretRotation(value:Number):void {			turretDirection = value;		}				public function get turretTargetRotation():Number {			return Math.floor(targetTurretDirection * 100)/100;		}			public function set turrentTargetRotation(value:Number):void {			targetTurretDirection = value;		}				public function get range():Number {			return shootingRange;		}				public function shoot(event:Event = null) {			// shooting in current direction!			if(canShoot && alive) {				reloadTimer.start();				canShoot = false;								var now:Date = new Date();				reloadTimerStarted = now.getTime();				// check collision				var shootEvent:GameObjectEvent = new GameObjectEvent(GameObjectEvent.SHOOT);					shootEvent.rotation = rotation + turret.rotation;					shootEvent.origin = new Point(this.x, this.y);					shootEvent.speed = speed;					shootEvent.ownerId = playerId;								dispatchEvent(shootEvent);			}		}				public override function pause(paused:Boolean = true):void {			super.pause(paused);						if(paused && reloadTimer.running) {				var now:Date = new Date();				reloadResume = reloadTimer.delay - (now.getTime() - reloadTimerStarted);				reloadTimer.stop();			}						if(!paused && reloadResume > 0) {				reloadTimer.delay = reloadResume;				reloadTimer.start();			}		}		private function releaseReloading(event:TimerEvent):void {			canShoot = true;						if(reloadResume > 0) {				reloadResume = 0;				reloadTimer.delay = reloadTime;			}						reloadTimer.stop();		}				// returns how much milliseconds remain on the reloader		public function get reloading():int {			if(reloadTimer && reloadTimer.running) {				var now:Date = new Date();				return reloadTimer.delay - (now.getTime() - reloadTimerStarted);			}			return 0;		}				public override function die():void {			unload();			super.die();		}				public override function hitRadius():Number {			if(!alive) {				return 0;			} else {				return super.hitRadius();			}		}				public override function hitbox(targetCoordinateSpace:DisplayObject):Rectangle {			if(!body) return new Rectangle();						return body.getBounds(targetCoordinateSpace);		}				public override function updateAudio(volume:Number, panning:Number):void {			if(!engineSound) return;						Audio.adjust(engineSound, volume, panning);		}				public override function hide():void {			super.hide();			mute();		}				public override function mute():void {			if(unloading || !engineSound) return;						lastVolume = engineSound.soundTransform.volume;			Audio.volume(engineSound, 0);		}				public override function unmute():void {			if(alive) {				Audio.volume(engineSound, lastVolume);			}		}				public override function unload():void {			if(unloading) return; // don't have to unload multiple times...			   unloading = true;						super.unload();						if(engineSound) {				engineSound.stop();				engineSound = null;			}			this.body = null;			this.turret = null;							if(reloadTimer.running) {				reloadTimer.stop();			}						reloadTimer.removeEventListener(TimerEvent.TIMER, releaseReloading);			reloadTimer = null;		}				public override function turnTo(target:Point = null):void {			// turn turret			var me:Point = new Point(this.x, this.y);						if(target == null) target = lastTarget;			lastTarget = target;						if(lastTarget == null) return;						// calculate distances			var xDistance:int = (me.x - target.x);			var yDistance:int = (me.y - target.y);						// convert to degrees			var rad:Number = Math.atan2(yDistance, xDistance);			targetTurretDirection = rad*(180/Math.PI);						// set 0 degrees to top			targetTurretDirection -= 90;									if(targetTurretDirection < -180) {				targetTurretDirection += 360;			}						if(targetTurretDirection > 180) {				targetTurretDirection -= 360;			}									targetTurretDirection -= this.rotation;									while(targetTurretDirection < -180) {				targetTurretDirection += 360;			}						while(targetTurretDirection > 180) {				targetTurretDirection -= 360;			}						if(targetTurretDirection != turretDirection) {				var deltaAngle:Number = targetTurretDirection - turretDirection;				deltaAngle += (deltaAngle < -180)?360:(deltaAngle > 180)?-360:0;								if(deltaAngle > 0.01) {					turretDirection += turretTurnSpeed;				} else {					turretDirection -= turretTurnSpeed;				}								// keep it in range of values.				turretDirection = (turretDirection < -180)?turretDirection += 360:turretDirection;				turretDirection = (turretDirection > 180)?turretDirection -= 360:turretDirection;								// snap if close to target:				if(Math.abs(turretDirection - targetTurretDirection) < turretTurnSpeed) {					turretDirection = targetTurretDirection;				}			}						if(turret) {				turret.rotation = turretDirection;			}		}				public function get myTarget():Point {			return lastTarget;		}				private function addTracks():void {			var tracks = new TankTracks(new Point(super.x, super.y));			tracks.rotation = rotation;			tracks.updateGfx();						myTracks.push(tracks);			parent.addChildAt(tracks, parent.getChildIndex(this));		}				public override function updateGfx():void {			super.updateGfx();						for(var t:uint = 0; t < myTracks.length; t++) {				if(!myTracks[t].isActive()) {					myTracks.splice(t, 1);				} else {					myTracks[t].updateGfx();				}			}		}				public function get distanceTraveled():int {			return travelDistance;		}				public override function tick():void {			super.tick();			if(!alive) return;						updateDistance();						turnTo();			handleTracks();		}				protected function updateDistance():void {			travelDistance += Math.abs(Math.sqrt(Math.pow(xVelocity,2) + Math.pow(yVelocity,2)));		}				protected function handleTracks():void {			if(travelDistance > lastTravelDistance + 20) {				lastTravelDistance = travelDistance;				addTracks();			}		}	}}
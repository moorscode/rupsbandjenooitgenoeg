/*Copyright (c) 2008 Christopher Martin-Sperry (audiofx.org@gmail.com)Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*//** * @author Mike Almond - MadeByPi * Added ID3 Parsing */package com.moorscode.sound.mp3 {		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.ProgressEvent;	import flash.events.IOErrorEvent;	import flash.net.FileReference;	import flash.net.URLLoader;	import flash.net.URLLoaderDataFormat;	import flash.net.URLRequest;	import flash.utils.ByteArray;		[Event(name="complete", type="flash.events.Event")]		internal class MP3Parser extends EventDispatcher {				private var _mp3Data			:ByteArray;		private var _loader				:URLLoader;		private var _currentPosition	:uint;		private var _sampleRate			:uint;		private var _channels			:uint;		private var _version			:uint;		private var _id3Reader			:ID3Reader;		private var _fileRef			:FileReference;				private static const bitRates		:Array 	= [-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1];		private static const versions		:Array	= [2.5,-1,2,1];		private static const samplingRates	:Array	= [44100,48000,32000];				public function MP3Parser() {			_mp3Data = new ByteArray();			_loader = new URLLoader();			_loader.dataFormat = URLLoaderDataFormat.BINARY;			_loader.addEventListener(Event.COMPLETE, loaderCompleteHandler, false, 0, true);		}				public function reset():void {			_mp3Data.length = 0;			_loader.data = null;			_id3Reader = null;		}				internal function load(url:String):void{			_loader.load(new URLRequest(url));		}				internal function loadFileRef(fileRef:FileReference):void{			_fileRef = fileRef;						_fileRef.addEventListener(Event.COMPLETE, loaderCompleteHandler, false, 0, true);			_fileRef.addEventListener(ProgressEvent.PROGRESS, progressHandler, false, 0, true);			_fileRef.addEventListener(IOErrorEvent.IO_ERROR, errorHandler, false, 0, true);			_fileRef.load();		}				private function errorHandler(ev:IOErrorEvent):void{			trace("error\n"+ev.text);		}				private function progressHandler(event:ProgressEvent):void {			trace('' + (100/event.bytesTotal) * event.bytesLoaded + '%');			dispatchEvent(event);		}				private function loaderCompleteHandler(ev:Event):void {			_fileRef.removeEventListener(Event.COMPLETE, loaderCompleteHandler);			_fileRef.removeEventListener(IOErrorEvent.IO_ERROR, errorHandler);						_mp3Data = null;			_mp3Data = ev.currentTarget.data as ByteArray;			_currentPosition = getFirstHeaderPosition();						dispatchEvent(ev);		}				private function getFirstHeaderPosition():uint{			_mp3Data.position = 0;						var readPosition:uint;			var str:String;			var val:uint;						var n:int = _mp3Data.length;						while (_mp3Data.position < n) {				readPosition 			= _mp3Data.position;				str 					= _mp3Data.readMultiByte(3, "us-ascii");								if(str == "ID3") {					readPosition 		= _mp3Data.position;					_id3Reader 	 		= new ID3Reader(_mp3Data);					_mp3Data.position 	= readPosition + _id3Reader.length;					readPosition 	 	= _mp3Data.position;					//trace("id3 parsed\n" + _id3Reader.id3.songName + " (" + _id3Reader.id3.track + ") : " + _id3Reader.id3.artist + " (" + _id3Reader.id3.album + ", " + _id3Reader.id3.year + ") " + " : " + _id3Reader.id3.encoder);				} else {					_mp3Data.position 	= readPosition;				}								var storedPos:uint = _mp3Data.position; //store it				val = _mp3Data.readInt();								if(isValidHeader(val)) {					parseHeader(val);					_mp3Data.position = readPosition + getFrameSize(val);					if(isValidHeader(_mp3Data.readInt())) {						return readPosition;					}				}								_mp3Data.position = storedPos + 1; //restore it			}						throw(new Error("Could not locate first header. This isn't an MP3 file"));		}				internal function getNextFrame():ByteArraySegment {			_mp3Data.position = _currentPosition;						var headerByte	:uint;			var frameSize	:uint;			var n			:int = _mp3Data.length - 4;						while(true){				if (_currentPosition > n){					//trace("passed eof");					return null;				}								headerByte = _mp3Data.readInt();								if(isValidHeader(headerByte)){					frameSize=getFrameSize(headerByte);					if(frameSize!=0xffffffff){						break;					}				}								_currentPosition = _mp3Data.position;			}						_mp3Data.position = _currentPosition;						if((_currentPosition + frameSize) > _mp3Data.length) {				return null;			}						_currentPosition += frameSize;						return new ByteArraySegment(_mp3Data, _mp3Data.position, frameSize);		}				internal function writeSwfFormatByte(byteArray:ByteArray):void {			var sampleRateIndex:uint = 4 - uint(44100 / _sampleRate);			byteArray.writeByte((2 << 4) + (sampleRateIndex << 2) + (1 << 1) + (_channels - 1));		}				private function parseHeader(headerBytes:uint):void{			var channelMode	:uint = getModeIndex(headerBytes);			_version = getVersionIndex(headerBytes);						var samplingRate:uint = getFrequencyIndex(headerBytes);			_channels = (channelMode > 2)? 1 : 2;						var actualVersion:Number = Number(versions[_version]);			_sampleRate = uint(samplingRates[samplingRate]);						switch(actualVersion){				case 2:					_sampleRate >>= 1;					break;				case 2.5:					_sampleRate >>= 2;			}		}				private function getFrameSize(headerBytes:uint):uint {			var version			:uint = getVersionIndex(headerBytes);			var bitRate			:uint = getBitrateIndex(headerBytes);			var samplingRate	:uint = getFrequencyIndex(headerBytes);			var sampleRate		:uint = samplingRates[samplingRate];			var padding			:uint = getPaddingBit(headerBytes);			var channelMode		:uint = getModeIndex(headerBytes);			var actualVersion	:Number = Number(versions[version]);						_sampleRate = sampleRate;						if (sampleRate != _sampleRate || _version != version) {				return 0xffffffff;			}						switch(actualVersion){				case 2:				_sampleRate >>= 1;				break;				case 2.5:				_sampleRate >>= 2;			}						var bitRatesYIndex	:uint = uint(actualVersion == 1 ? 0 : bitRates.length >> 1);			var actualBitRate	:uint = uint(bitRates[bitRatesYIndex + bitRate] * 1000);			var frameLength		:uint = uint(((actualVersion == 1 ? 144 : 72) * actualBitRate) / sampleRate) + padding;						return frameLength;		}				public function get samplerate():Number {			return _sampleRate;		}			 	private function isValidHeader(headerBits:uint):Boolean {	        return (((getFrameSync(headerBits)      & 2047)==2047) &&	                ((getVersionIndex(headerBits)   &    3)!=   1) &&	                ((getLayerIndex(headerBits)     &    3)!=   0) &&	                ((getBitrateIndex(headerBits)   &   15)!=   0) &&	                ((getBitrateIndex(headerBits)   &   15)!=  15) &&	                ((getFrequencyIndex(headerBits) &    3)!=   3) &&	                ((getEmphasisIndex(headerBits)  &    3)!=   2));	    }		    private function getFrameSync(headerBits:uint):uint{	        return uint((headerBits>>21) & 2047);	    }		    private function getVersionIndex(headerBits:uint):uint{	        return uint((headerBits>>19) & 3);	    }		    private function getLayerIndex(headerBits:uint):uint{	        return uint((headerBits>>17) & 3);	    }		    private function getBitrateIndex(headerBits:uint):uint{	        return uint((headerBits>>12) & 15);	    }		    private function getFrequencyIndex(headerBits:uint):uint{	        return uint((headerBits>>10) & 3);	    }		    private function getPaddingBit(headerBits:uint):uint{	        return uint((headerBits>>9) & 1);	    }		    private function getModeIndex(headerBits:uint):uint{	        return uint((headerBits>>6) & 3);	    }		    private function getEmphasisIndex(headerBits:uint):uint{	        return uint(headerBits & 3);	    }				public function get id3():ID3 {			return ((_id3Reader)?_id3Reader.id3:new ID3());		}	}}
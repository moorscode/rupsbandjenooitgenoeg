package {	import flash.display.*;		import flash.events.*;		import flash.external.ExternalInterface;		import flash.geom.Point;	import flash.geom.Rectangle;		import flash.media.SoundChannel;		import flash.net.SharedObject;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.net.URLVariables;		import flash.text.TextField;		import flash.utils.Timer;	import flash.utils.getTimer;		import flash.ui.Keyboard;		import fl.data.DataProvider;		import fl.controls.Button;	import fl.controls.CheckBox;	import fl.controls.DataGrid;	import fl.controls.dataGridClasses.DataGridColumn;	import fl.controls.TileList;	import fl.controls.ProgressBar;		import com.moorscode.game.*;		import com.moorscode.input.Input;	import com.moorscode.interfaces.LevelSelectRenderer;	import com.moorscode.net.NetController;	import com.moorscode.net.NetEvent;	import com.moorscode.sound.Audio;	import com.moorscode.rupsbandjenooitgenoeg.*;		import com.everydayflash.equalizer.*;	import com.everydayflash.equalizer.color.*;		import com.lifeztream.debug.FPS;		public class rupsbandjenooitgenoeg extends GameSkeleton {		private var nextLevel:uint = 1;		private var lastCompletedLevel:uint = 0;		private var pauseField:Sprite;		private var HUD:Sprite;				private var enemyHP:Sprite;		private var enemyHPTank:EnemyTank;				private var levelMusic:SoundChannel;		private var menuMusic:SoundChannel;				private var currentMenu:Sprite;		private var menuTimer:Timer;				private var playerId:int = 0;		private var isOwner:Boolean = false;		private var singlePlayer:Boolean = true;				private var netMenu:Sprite;				private var enemyPlayers:uint = 0;		private var dpPlayerList:DataProvider = new DataProvider();				private var players:Array;		private var playerIndex:uint = 0;		private var followIndex:uint = 0;				private var wonTheGame:Boolean = false;				private var gameOver:Boolean = false;				private var dpOverview:DataProvider = new DataProvider();		private var showingOverview:Boolean = false;		private var overviewWindow:Sprite;				private var lastNetUpdate:uint = 0;		private var lastSendPlayerInfo:XML;				private var bgManager:GameBackgroundManager;				private var equalizer:Equalizer;		private var equalizerTimer:Timer = new Timer(30, 0);		private var equalizerSettings:EqualizerSettings;				// constructor; variables will be filled when in MP, otherwise empty		public function rupsbandjenooitgenoeg(players:Array = null, playerId:int = 0, isOwner:Boolean = false):void {			this.isOwner = isOwner;			this.playerId = playerId;						this.players = (players == null)?new Array(new Array(0)):players;						enemyPlayers = this.players.length - 1;			singlePlayer = Boolean(this.players.length == 1 || !NetController.connected);						Audio.initialize();						if(!singlePlayer) {				addNetEventListeners();								playerIndex   = getPlayerIndex(playerId);				followIndex   = playerIndex;								pauseOnBlur   = false;				pauseDisabled = true;								gameOver 	  = false;			} else {				Audio.muteMusic = true;				addEventListener(ProgressEvent.PROGRESS, loadingProgress);			}									//addChild(new FPS());						// add event listeners			addEventListener(GameEvent.LOADED, loadComplete);						addEventListener(GameEvent.PAUSED, handlePause);			addEventListener(GameEvent.UNPAUSED, handlePause);						addEventListener(GameEvent.TICK, tick);			addEventListener(GameEvent.FRAME, frame);						addEventListener(GameEvent.ENDED, finishLevel);		}				private function loadingProgress(event:ProgressEvent):void {			var wndLoading:Sprite = getChildByName('wndLoading') as Sprite;						ProgressBar(wndLoading['progressLoading']).minimum = 0.0;			ProgressBar(wndLoading['progressLoading']).maximum = 1.0;						ProgressBar(wndLoading['progressLoading']).value = (1/event.bytesTotal) * event.bytesLoaded;		}				// INIT - initialize - after Library is loaded - MP Select Level		private function loadComplete(event:Event):void {			if(singlePlayer) {				var wndLoading:Sprite = getChildByName('wndLoading') as Sprite;					wndLoading.visible = false;			}						equalizerSettings = new EqualizerSettings();			equalizerSettings.numOfBars = 32;			equalizerSettings.height = stage.stageHeight * 0.75;			equalizerSettings.barSize = stage.stageWidth / equalizerSettings.numOfBars;			equalizerSettings.vgrid = true;			equalizerSettings.hgrid = 2;			equalizerSettings.colorManager = new GradientBarColor(); // 0xffff4444			equalizerSettings.effect = EqualizerSettings.FX_REFLECTION;						equalizer = new Equalizer(equalizerSettings);			equalizerTimer.addEventListener(TimerEvent.TIMER, equalizer.render);						pauseField = getSprite("pauseField");			pauseField.name = "pauseField";			pauseField.x = stage.stageWidth / 2.0;			pauseField.y = stage.stageHeight / 2.0;						stage.focus = stage;			Input.clearInput();						// laat menu zien bij singleplayer			if(singlePlayer) {				// laad 'last completed level' settings uit de database				var url:URLLoader = new URLLoader();					url.addEventListener(Event.COMPLETE, setLevelCompleted, false, 0, true);					url.addEventListener(IOErrorEvent.IO_ERROR, setLevelCompleted, false, 0, true);					url.load(new URLRequest("assets/php/splevel.php"));			} else {				overviewWindow = getSprite("wndPlayerOverview");								var dgOverview = overviewWindow.getChildByName("dgOverview");					dgOverview.showHeaders = false;					dgOverview.rowHeight = 20;										dgOverview.addColumn("naam");								var hpColumn:DataGridColumn = dgOverview.addColumn("HP");					hpColumn.width = 40;									dgOverview.dataProvider = dpOverview;								netSelectLevel();			}		}				// DATABASE - retrieve last completed level information		private function setLevelCompleted(event:*):void {			event.target.removeEventListener(IOErrorEvent.IO_ERROR, arguments.callee);			event.target.removeEventListener(Event.COMPLETE, arguments.callee);						if(event.type == Event.COMPLETE) {				var xml:XML = XML(event.target.data);								if(xml != '') {					lastCompletedLevel = uint(xml.lastCompletedLevel);					nextLevel = lastCompletedLevel;				}			}						showMenu("menuMain");			ExternalInterface.addCallback("playSound", JSSoundRequest);		}				// SOUND - Javascript sound request - play sound		private function JSSoundRequest(sound:String):void {			// only play sounds when in menu.			if(currentMenu) {				Audio.playSound(sound+".mp3");			}		}				// MENU - show the singleplayer menu		private function showMenu(menu:String):void {			cleanUpMenu(true);									JavaScript("leavingGame");						if(!menuMusic) {				menuMusic = Audio.playMusic("menuMusic.mp3", true, 0.7);			}						currentMenu = Sprite(addChild(getSprite(menu)));			currentMenu.x = (GameCamera.width / 2.0) - (currentMenu.width / 2.0);			currentMenu.y = (GameCamera.height / 2.0) - (currentMenu.height / 2.0);			currentMenu.name = menu;						switch(menu) {				case "menuMain":					currentMenu.y += 33;					// convert button to action					createButton(Sprite(currentMenu.getChildByName("btnStart")), startNextLevel);										// control the music checkbox					var toggleMusic:CheckBox = CheckBox(currentMenu.getChildByName("toggleMusic"));						toggleMusic.addEventListener(MouseEvent.CLICK, handleMusic, false, 0, true);						toggleMusic.selected = !Audio.muteMusic;										if(toggleMusic.selected) {						addChildAt(equalizer, 0);						equalizerTimer.start();					}															var levelSelect:TileList = TileList(currentMenu.getChildByName("levelSelect"));						levelSelect.setStyle("cellRenderer", LevelSelectRenderer);										var checkLevel:uint = 1;										// fill the level-select tile list					var done:Boolean = false;					while(!done) {						try {							var level:Sprite = getSprite("level" + checkLevel);							levelSelect.addItem({label:"level " + checkLevel, scaleContent:false});														// set all but last level as 'completed'							if(checkLevel <= lastCompletedLevel) {								var previousItem:Object = levelSelect.getItemAt(levelSelect.length-1);									previousItem.source = "assets/html/images/done.gif";							}						} catch(e:Error) {							done = true;						}												// only show the completed levels + 1 extra						done = done || (checkLevel == lastCompletedLevel + 1);						checkLevel++;					}										levelSelect.selectedIndex = (nextLevel == levelSelect.length) ? nextLevel - 1 : nextLevel;										break;								case "menuFinalVictory":				case "menuVictory":				case "menuDefeated":										var delayTime:int = (menu == "menuFinalVictory")?6000:2000;										// show the screen for 2 seconds, then return					menuTimer = new Timer(delayTime, 1);										menuTimer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent = null) {						event.target.stop();						event.target.removeEventListener(event.type, arguments.callee);												showMenu("menuMain");					});										menuTimer.start();										break;			}		}				// MENU - Remove the menu and stop the music		private function cleanUpMenu(stopAudio:Boolean = false):void {						// if a menu is shown, remove it			if(currentMenu) {				if(currentMenu.getChildByName("btnStart")) {					removeButton(Sprite(currentMenu.getChildByName("btnStart")), startNextLevel);				}								removeChild(currentMenu);				currentMenu = null;			}						if(menuMusic && !stopAudio) {				menuMusic.stop();				menuMusic = null;			}						if(contains(equalizer)) {				removeChild(equalizer);			}						if(equalizerTimer.running) {				equalizerTimer.stop();			}		}				// SOUND - handle clicking the mute button on the main-menu		private function handleMusic(event:Event):void {			var music:CheckBox = CheckBox(event.target);			if(!music.selected) {				// Audio.musicVolume = 0.0;				if(equalizerTimer.running) {					equalizerTimer.stop();				}								if(contains(equalizer)) {					removeChild(equalizer);				}								Audio.muteMusic = true;			} else {				Audio.muteMusic = false;				// Audio.musicVolume = 1.0;								//menuMusic = Audio.playMusic("menuMusic.mp3", true, 0.7);				equalizerTimer.start();								if(!contains(equalizer)) {					addChildAt(equalizer, 0);				}			}		}				// NET - select level and start it		private function netSelectLevel():void {			// prepare game controls			Button(overviewWindow.getChildByName("btnResume")).addEventListener(MouseEvent.CLICK, hideOverview, false, 0, true);			Button(overviewWindow.getChildByName("btnLeave")).addEventListener(MouseEvent.CLICK, cleanUp, false, 0, true);						var xml:XML;						// if isOwner, select mp level			if(isOwner) {				var i:uint = 0;				var levelTest:Sprite;				var done:Boolean = false;				var eligableLevels = new Array();								// count: mpStartPosition's				while(!done) {					i++;										var positions:uint = 0;										try {						levelTest = getSprite("level" + i);												var children:uint = levelTest.numChildren;						for(var c:uint = 0; c < children; c++) {							var child = levelTest.getChildAt(c);							positions += (getLogicalClassName(child) == "mpStartPosition")?1:0;						}												if(positions > enemyPlayers) {							eligableLevels.push(new Array(i, positions));						}					} catch(e:Error) {						done = true;					}				}								var loadLevel = Math.round(Math.random() * (eligableLevels.length-1));					nextLevel = eligableLevels[loadLevel][0];								xml = <a>						<t>game</t>						<w>level</w>						<n>{eligableLevels[loadLevel][0]}</n>						<s>{eligableLevels[loadLevel][1]}</s>					  </a>;								NetController.send(xml);			} else {				// request level info + start position				xml = <a>						<t>game</t>						<w>loaded</w>					  </a>;								NetController.send(xml);			}		}				// GAME - initialize and start the game		private function startLevel(netGame:Boolean = false):void {			var level:Sprite;						nextLevel = Math.max(nextLevel, 1); // minimum level = 1, not 0						try {				level = getSprite("level" + nextLevel);			} catch(e:Error) {				nextLevel--;				startLevel();				return;			}						var p:uint = 0;			for(p = 0; p < players.length; p++) {				if(p == playerIndex) {					players[p]['tank'] = new PlayerTank(players[p][0], players[p]['rank']);				} else {					players[p]['tank'] = new NetPlayerTank(players[p][0], players[p]['rank']);					players[p]['tank'].addEventListener(GameObjectEvent.REMOVE, removeNetPlayer, false, 0, true);					players[p]['tank'].addEventListener("hpChange", updateOverview, false, 0, true);										players[p]['HP'] = Sprite(addChild(getSprite("HPenemy")));					TextField(players[p]['HP'].getChildByName("EnemyName")).text = players[p][1];				}								players[p]['tank'].setRank(players[p]['rank']);								players[p]['dead'] 	= false;				players[p]['ready'] = false;								players[p]['tank'].addEventListener(GameObjectEvent.SHOOT, fireBullet, false, 0, true);				players[p]['tank'].addEventListener(GameObjectEvent.DESTROYED, handleDeath, false, 0, true);								addChild(players[p]['tank']);			}						// set the camera-follow-target			followIndex = playerIndex;						// place the objects in the level and set starting positions			placeObjects(level);			level = null;						// play the level-music			levelMusic = Audio.playMusic("levelMusic.mp3", true, 0.7);									bgManager = new GameBackgroundManager();			addChildAt(bgManager, 0);									// place the hud			HUD = Sprite(addChild(getSprite("HUD")));			HUD.alpha = 0.8;			HUD.y = GameCamera.height - HUD.height;			HUD.x = GameCamera.width / 2.0 - HUD.width / 2.0;						// set enemy counter in the hud			var totalTanks:Array = GameObjectList.getAll("EnemyTank");			TextField(HUD.getChildByName("tanksLeft")).text = "" + ((singlePlayer)?totalTanks.length:aliveNetPlayers());						// maintain proper z-indexing			setChildIndex(HUD, numChildren - 1);						// handle z-indexing			if(players.length > 1) {				for(p = 0; p < players.length; p++) {					if(p != playerIndex) {						setChildIndex(players[p]['HP'], getChildIndex(HUD) - 1);					}				}								setChildIndex(players[playerIndex]['tank'], getChildIndex(HUD) - players.length);								for(p = 0; p < players.length; p++) {					if(p != playerIndex) {						setChildIndex(players[p]['tank'], getChildIndex(players[playerIndex]['tank']) - 1);					}				}			}						// tree z-indexing			var treeList:Array = GameObjectList.getAll("Tree");			for(var t:uint = 0; t < treeList.length; t++) {				setChildIndex(treeList[t], getChildIndex(HUD) - players.length);			}						// pre-set camera point			var center:Tank = Tank(players[followIndex]['tank']);				GameCamera.x = center.x - ((center.x - Input.mouseCoords.x) / 2.0);				GameCamera.y = center.y - ((center.y - Input.mouseCoords.y) / 2.0);						if(netGame) {				showNetMenu();				updateOverview();			} else {				startGame();			}		}				// INIT: Place Objects - convert the template to the game		private function placeObjects(template:Sprite):void {			var startPosition:uint = 0;						// go through all objects and replace!			var children:uint = template.numChildren;			for(var c:uint = 0; c < children; c++) {				var child = template.getChildAt(0);				var coords:Point = new Point(DisplayObject(child).x, DisplayObject(child).y);				coords.x = Math.round(coords.x);				coords.y = Math.round(coords.y);								switch(getLogicalClassName(child)) {					case "TankHolder":						if(singlePlayer) {							createEnemy("EnemyTank", coords);						}						break;					case "TreeHolder":						createEnemy("Tree", coords);						break;					case "mpStartPosition":						if(!singlePlayer) {							for(var p:uint = 0; p < players.length; p++) {								if(players[p]['position'] == startPosition) {									players[p]['tank'].setPosition(coords);								}							}							startPosition++;						}						break;				}								template.removeChild(child);			}		}				// NET - start game		private function netStartLevel():void {			removeNetMenu();						GameTimer.start();						stage.addEventListener(KeyboardEvent.KEY_UP, handleKeys, false, 0, true);						startGame();		}						private function handleKeys(event:KeyboardEvent):void {			if(event.keyCode == 27) {				// toggle the overview				showOverview(!showingOverview);			}		}				private function updateOverview(event:Event = null) {			// update the overview datagrid						dpOverview.removeAll();						for(var p:uint = 0; p < players.length; p++) {				dpOverview.addItem({naam:players[p][1], HP:players[p]['tank'].HP});			}									dpOverview.sortOn("HP", Array.DESCENDING | Array.NUMERIC);						// replace all with 0 HP to be 'dead'			for(var index:uint = dpOverview.length-1; index > 0; index--) {				if(dpOverview.getItemAt(index).HP == 0) {					dpOverview.getItemAt(index).HP = "dead";				} else {					break;				}			}		}				private function hideOverview(event:Event = null):void {			showOverview(false);		}				private function showOverview(visibility:Boolean):void {			if(!visibility) {				if(contains(overviewWindow)) {					removeChild(overviewWindow);				}			} else {				if(!contains(overviewWindow)) {					overviewWindow.x = stage.stageWidth / 2.0;					overviewWindow.y = stage.stageHeight / 2.0;					addChild(overviewWindow);				}			}						Button(overviewWindow.getChildByName("btnResume")).enabled = !gameOver;						if(gameOver) {				if(stage.hasEventListener(KeyboardEvent.KEY_UP)) {					stage.removeEventListener(KeyboardEvent.KEY_UP, handleKeys);				}			}						showingOverview = visibility;						if(players[playerIndex] && players[playerIndex]['tank']) {				players[playerIndex]['tank'].pause(showingOverview);			}		}						// GAME - start the next level		private function startNextLevel(event:Event = null) {			cleanUpMenu();						if(event != null) {				var levelSelect:TileList = TileList(Sprite(event.target.parent).getChildByName("levelSelect"));				nextLevel = levelSelect.selectedIndex + 1;			}						startLevel();		}				// GAME - at completion of the level		private function finishLevel(event:Event = null):void {			Input.clearInput();						if(stage.hasEventListener(KeyboardEvent.KEY_UP)) {				stage.removeEventListener(KeyboardEvent.KEY_UP, handleKeys);			}						levelMusic.stop();			levelMusic = null;						players[playerIndex]['tank'].removeEventListener(GameObjectEvent.SHOOT, fireBullet);			players[playerIndex]['tank'].removeEventListener(GameObjectEvent.DESTROYED, handleDeath);			players[playerIndex]['tank'] = null;						if(!singlePlayer) {				while(players.length > 0) {					if(players[0]['tank']) {						players[0]['tank'].removeEventListener(GameObjectEvent.SHOOT, fireBullet);						players[0]['tank'].removeEventListener(GameObjectEvent.DESTROYED, handleDeath);												if(players[0]['tank'].hasEventListener(GameObjectEvent.REMOVE)) {							players[0]['tank'].removeEventListener(GameObjectEvent.REMOVE, removeNetPlayer);						}												players[0]['tank'] = null;						players[0]['HP'] = null;						players[0]['dead'] = null;					}										players.shift();				}			}						if(enemyHP && contains(enemyHP)) {				removeChild(enemyHP);			}						bgManager = null;			enemyHP = null;			enemyHPTank = null;						/* remove HUD */			if(HUD && contains(HUD)) {				removeChild(HUD);			}						if(!singlePlayer) return;						if(wonTheGame == true) {								lastCompletedLevel = Math.max(lastCompletedLevel, nextLevel);								// test to see if this was the last level..				// if the next level can't be loaded, show the final victory screen				var finished:Boolean = false								try {					var test:Sprite = getSprite("level" + nextLevel);					showMenu("menuVictory");				} catch(e:Error) {					showMenu("menuFinalVictory");					finished = true;				}								// save lastCompletedData to the database				var levelData:URLVariables = new URLVariables();					levelData.lastCompletedLevel = lastCompletedLevel;					levelData.finished = (finished)?1:0;								var saveRequest:URLRequest = new URLRequest("assets/php/splevel.php");					saveRequest.method = URLRequestMethod.POST;					saveRequest.data = levelData;							var url:URLLoader = new URLLoader();					url.addEventListener(IOErrorEvent.IO_ERROR, function(e:Event) { return; });					url.load(saveRequest);							} else {				showMenu("menuDefeated");			}		}				// NET - clean up before closing		private function cleanUp(event:* = null):void {			removeNetEventListeners();			removeNetMenu();						NetController.enablePing(false);						cleanUpMenu();			endGame();						if(!singlePlayer) {				gameOver = true;								var xml:XML = <a>								<t>game</t>								<w>leave</w>							  </a>;								NetController.send(xml, true);								dispatchEvent(new Event(Event.CLOSE));			}		}				// GFX - physically add the enemy to the stage		private function createEnemy(type:String, position:Point):void {			switch(type) {				case "EnemyTank":					var enemy:EnemyTank = new EnemyTank(position)					enemy.addEventListener(GameObjectEvent.DESTROYED, handleDeath);					enemy.addEventListener(GameObjectEvent.SHOOT, fireBullet);					enemy.addEventListener(MouseEvent.MOUSE_MOVE, showEnemyHP);					addChildAt(enemy, 0);					break;				case "Tree":					addChild(new Tree(position, getSprite("tree")));					break;			}		}				// NET - remove player from the game		private function removeNetPlayer(event:GameObjectEvent):void {			var pidx:uint = getPlayerIndex(event.ownerId);						if(players[pidx]) {				if(players[pidx]['tank']) {					players[pidx]['tank'].forceDie();				}			}						TextField(HUD.getChildByName("tanksLeft")).text = "" + aliveNetPlayers();						updateOverview();		}				// INPUT - pause / unpause for defocus		private function handlePause(event:Event = null):void {			if(paused) {				// add pause field				addChild(pauseField);			} else {				// remove pause field, if active				if(getChildByName("pauseField")) {					removeChild(pauseField);				}			}		}		// MATH - tick (!!)		public function tick(event:Event = null):void {			// the player is always in the middle of the screen			// if the player is dead, follow the highest HP tank			var center:Tank = Tank(players[followIndex]['tank']);			if(players[followIndex]['dead']) {				var followHP:Number = 0;								for(var p:uint = 0; p < players.length; p++) {					if(!players[p]['dead'] && players[p]['tank'].HP > followHP) {						followIndex = p;						followHP = players[p]['tank'].HP;					}				}								center = Tank(players[followIndex]['tank']);			}						GameCamera.x = center.x; // - ((center.x - Input.mouseCoords.x) * 0.2);			GameCamera.y = center.y; // - ((center.y - Input.mouseCoords.y) * 0.2);			GameCamera.rotation = center.rotation;						// update ping-time to javascript (for debugging purposes)			JavaScript("showPing", String(NetController.ping));						// main game tick.			updatePlayers();						// update enemys			updateEnemies();						// update bullets			updateBullets();		}				// GFX - per frame updates		public function frame(event:Event = null):void {			// check for input:			// checkKeys();						// HUD/GUI update			for(var p:uint = 0; p < players.length; p++) {				// hud updates (reload timer)				if(p == playerIndex) {					var percentage:Number = (1 / players[p]['tank'].reloadTime) * players[p]['tank'].reloading;						percentage = Math.max(0, 1 - Math.round(percentage * 100) / 100);										var reloadBar:Sprite = Sprite(Sprite(HUD.getChildByName("ReloadTimer")).getChildByName("ReloadLeft"));					if(reloadBar.scaleX != percentage) {						reloadBar.scaleX = percentage;					}				} else {					// update HUD on players - if they are alive..					if(players[p]['tank'].alive) {						players[p]['HP'].x = players[p]['tank'].x + 10 - GameCamera.x;						players[p]['HP'].y = players[p]['tank'].y - 10 - GameCamera.y - (players[p]['tank'].height / 2.0);												var HPMeter:Sprite = Sprite(players[p]['HP'].getChildByName("HPmeter"));							Sprite(HPMeter.getChildByName("HPleft")).scaleX = (1 / players[p]['tank'].maxHP) * players[p]['tank'].HP;							TextField(HPMeter.getChildByName("HPtext")).text = players[p]['tank'].HP + "/" + players[p]['tank'].maxHP;					} else if(players[p]['HP'] != null) { // if dead but HP is showing, remove it..						if(contains(players[p]['HP'])) {							removeChild(players[p]['HP']);						}												players[p]['HP'] = null;					}				}			}						// Update to NET: after all calculations are done.			if(!singlePlayer) {				/* tickTime = time between frames */				if(lastNetUpdate == 0 || lastNetUpdate < getTimer() - Math.max(NetController.ping, tickTime*2)) {					lastNetUpdate = getTimer();					sendNetUpdates();				}			} else {				updateEnemyHP();			}		}				// MATH - update players		public function updatePlayers():void {			if(players.length == 0) return;						// bounce on trees			var treeList:Array = GameObjectList.getAll("Tree");			for(var t:uint = 0; t < treeList.length; t++) {				bounce(players[playerIndex]['tank'], treeList[t]);			}						// bounce on other players			if(players.length > 1) {				for(var p:uint = 0; p < players.length; p++) {					// bounce on other players:					if(p != playerIndex) {						bounce(players[playerIndex]['tank'], players[p]['tank']);					}				}			}		}				// MATH - update enemy turning / ticking if in screen:		private function updateEnemies():void {			if(players.length == 0) return;						var player:PlayerTank = PlayerTank(players[playerIndex]['tank']);			var enemyTankList:Array = GameObjectList.getAll("EnemyTank");						var playerPosition:Point = new Point(player.x, player.y);						for(var t:uint = 0; t < enemyTankList.length; t++) {				var enemy:EnemyTank = EnemyTank(enemyTankList[t]);								if(enemy.alive) {					if(enemy.inScreen) {						var surround:Array = calculateSurround(playerPosition, new Point(enemy.x, enemy.y));						enemy.updateAudio(surround['volume'], surround['panning']);					}									if(enemy.inRange(playerPosition)) {						enemy.turnTo(playerPosition);						bounce(player, enemy, "rectangular");					}				}			}		}				// MATH - update bullets, movement / collision		public function updateBullets(pid:int = -1, bid:int = -1):void {			var explode:Boolean = false;						var bulletList:Array = GameObjectList.getAll("Bullet");			for(var b:uint = 0; b < bulletList.length; b++) {								// if a specified (net)player is specified:				if(pid > -1) {					if(bulletList[b].owner != pid) continue;										// if a bullet is specified:					if(bid > -1) {						if(bulletList[b].identifier != bid) continue;					}				}								// check enemies				var enemyTankList:Array = GameObjectList.getAll("EnemyTank");				for(var e:uint = 0; e < enemyTankList.length; e++) {					if(collides(enemyTankList[e], bulletList[b])) {						enemyTankList[e].hit();						explode = true;					}				}								// check bullets				var treeList:Array = GameObjectList.getAll("Tree");				for(var t:uint = 0; t < treeList.length; t++) {					if(collides(treeList[t], bulletList[b])) {						explode = true;					}				}								// check bullets on player - including id + owner				if(players[playerIndex]['tank']) {					var player:Tank = Tank(players[playerIndex]['tank']);					if(collides(player, bulletList[b]) && bulletList[b].owner != players[playerIndex][0]) {												player.hit();												Sprite(Sprite(HUD.getChildByName("HPmeter")).getChildByName("HPleft")).scaleX = (1 / player.maxHP) * player.HP;						TextField(Sprite(HUD.getChildByName("HPmeter")).getChildByName("HPtext")).text = player.HP + "/" + player.maxHP;												explode = true;																	// send bullet hit event to server if multiplayer!						if(!singlePlayer) {							var hitEvent:XML = <a>												<w>hit</w>												<bi>{Bullet(bulletList[b]).toString()}</bi>												<x>{bulletList[b].x}</x>												<y>{bulletList[b].y}</y>												<time>{GameTimer.time}</time>											   </a>;														NetController.send(hitEvent);						}					}				}								if(explode && bulletList[b]) {					spawnExplosion(new Point(bulletList[b].x, bulletList[b].y));					bulletList[b].unload();				}			}		}				// GAME - when something fires a bullet		private function fireBullet(event:GameObjectEvent):void {			var origin:Point = event.origin;						if(singlePlayer || event.ownerId == playerId) {				origin.x += 30 * Math.cos((event.rotation-90) * Math.PI / 180);				origin.y += 30 * Math.sin((event.rotation-90) * Math.PI / 180);			}						var me:IGameObject = IGameObject(players[playerIndex]['tank']);						var surround:Array = calculateSurround(new Point(me.x, me.y), origin);			Audio.playSound("shoot.mp3", surround['volume'], surround['panning']);						var bullet = new Bullet(origin, event.rotation, event.ownerId, event.bulletId);				bullet.addEventListener(GameObjectEvent.DESTROYED, removeBullet);						if(contains(players[playerIndex]['tank'])) {				addChildAt(bullet, getChildIndex(players[playerIndex]['tank'])+1);			} else {				return;			}						for(var t:uint = 0; t<event.fforward; t++) {				bullet.tick();				updateBullets(event.ownerId, bullet.identifier);			}						/* If this player shoots;			 * Send bullet info to the server			 * send the time the update is send			 */			if(singlePlayer || event.ownerId != playerId) return;						var xml:XML = <a>							<t>game</t>							<w>shoot</w>							<p><x>{event.origin.x-10}</x><y>{event.origin.y-10}</y></p>							<r>{event.rotation}</r>							<s>{event.speed}</s>							<bid>{bullet.identifier}</bid>							<time>{GameTimer.time}</time>						  </a>;						NetController.send(xml, true);			lastNetUpdate = getTimer();		}				// GAME - when something dies		private function handleDeath(event:GameObjectEvent):void {			var totalTanks:Array = GameObjectList.getAll("EnemyTank");			var isEnemy:Boolean = true;						switch(getLogicalClassName(event.targetObject)) {				case "EnemyTank":					TextField(HUD.getChildByName("tanksLeft")).text = "" + totalTanks.length;										if(event.targetObject == enemyHPTank) {						removeChild(enemyHP);						enemyHP = null;						enemyHPTank = null;					}										break;				case "NetPlayerTank":					players[getPlayerIndex(event.ownerId)]['dead'] = true;					TextField(HUD.getChildByName("tanksLeft")).text = "" + aliveNetPlayers();					break;				case "PlayerTank":					isEnemy = false;										if(singlePlayer) {						wonTheGame = false;						endGame();						return;					} else {						var xml:XML = <a>										<t>game</t>										<w>died</w>									  </a>;												NetController.send(xml, true);												gameOver = true;						players[playerIndex]['dead'] = true;																		Button(overviewWindow.getChildByName("btnResume")).enabled = false;												updateOverview();						showOverview(true);					}					break;			}						// only tanks can die, so add a corpse!			addChildAt(new TankCorpse(new Point(event.targetObject.x, event.targetObject.y), event.targetObject.rotation, isEnemy), 1);						// only unload the target after all the data is read			event.targetObject.unload();						if(singlePlayer && totalTanks.length == 0) {				wonTheGame = true;								// end the game				endGame();			}		}				// NET - send player data to the server		private function sendNetUpdates():void {			if(players.length == 0) return;						// send updates			var player:PlayerTank = PlayerTank(players[playerIndex]['tank']);			var acceleration = (player.accelerating)?1:((player.decelerating)?-1:0);						var targetX:Number = Math.round(player.myTarget.x * 100) / 100;			var targetY:Number = Math.round(player.myTarget.y * 100) / 100;						var speed:Number = Math.round(player.speed * 1000) / 1000;						// create xml to send			var xml:XML = <a>							<t>game</t>							<w>playerinfo</w>							<d>{player.distanceTraveled}</d>							<p><x>{player.x}</x><y>{player.y}</y></p>							<tar><x>{targetX}</x><y>{targetY}</y></tar>							<hp>{player.HP}</hp>							<rot>{player.rotation}</rot>							<spd>{speed}</spd>							<acc>{acceleration}</acc>							<trd>{player.turretRotation}</trd>							<trtd>{player.turretTargetRotation}</trtd>							<time>{GameTimer.time}</time>						  </a>;						NetController.send(xml, true);			lastNetUpdate = getTimer();		}				// Remove the bullet		private function removeBullet(event:GameObjectEvent):void {			event.targetObject.removeEventListener(event.type, arguments.callee);						spawnExplosion(event.origin);						var target = event.targetObject;				target.unload();						if(!singlePlayer) {				if(event.ownerId == players[playerIndex][0]) {					// send MISS to server					var xml:XML = <a>									<t>game</t>									<w>miss</w>								  </a>;										NetController.send(xml);				}			}		}				// NET - handle incoming data		private function parseNetData(event:NetEvent):void {			var xmlData:XML = event.xml;						var p:uint;			var pidx:uint;			var pid:int;						var what:String;			var playerName:String;			var isReady:String;						// request starting position			// show ready button - wait for all players ready			// add event listeners to net controller						switch(String(xmlData.t)) {				case "game":					what = String(xmlData.w);										if(what == "startpos") {						// set the level to be played:						nextLevel = int(xmlData.l);												// recieve all positions at once!						// initialize start position + rank						for each(var position:XML in xmlData.ps.p) {							pidx = getPlayerIndex(int(position.i));							players[pidx]['position'] = int(position.pos);							players[pidx]['rank'] = int(position.rank);						}												// show ready button, show ready for other players						startLevel(true);						NetController.enablePing();												// reset playerlist						dpPlayerList.removeAll();						for(p = 0; p < players.length; p++) {							if(p != playerIndex) {								dpPlayerList.addItem({speler:players[p][1], ready:''});							}						}					}										if(what == "ready") {						pidx = getPlayerIndex(int(xmlData.i));						players[pidx]['ready'] = true;												// dpPlayersList						dpPlayerList.removeAll();						for(p = 0; p < players.length; p++) {							if(p != playerIndex) {								isReady = (players[p]['ready'])?"READY!":"";								dpPlayerList.addItem({speler:players[p][1], ready:isReady});							}						}					}										if(what == "remove" && !inGame) {						// remove the player from the ready-list						pidx = getPlayerIndex(xmlData.i);						players.splice(pidx, 1);												// dpPlayersList						dpPlayerList.removeAll();						for(p = 0; p < players.length; p++) {							if(p != playerIndex) {								isReady = (players[p]['ready'])?"READY!":"";								dpPlayerList.addItem({speler:players[p][1], ready:isReady});							}						}					}										if(what == "start") {						netStartLevel();					}										if(what == "hit") {						var bid:int = int(xmlData.bid); // bullet id						var oid:int = int(xmlData.oid); // bullet owner id												var bulletFound:Boolean = false;												// find the bullet..						var bulletList:Array = GameObjectList.getAll("Bullet");						for(var b:int = 0; b < bulletList.length; b++) {							if(bulletList[b].toString() == ""+oid+"|"+bid+"") {																var destroyBullet:GameObjectEvent = new GameObjectEvent(GameObjectEvent.DESTROYED);									destroyBullet.targetObject = bulletList[b];									destroyBullet.origin = new Point(xmlData.x, xmlData.y);									destroyBullet.ownerId = oid;																removeBullet(destroyBullet);																bulletFound = true;							}						}												// if the bullet has already been removed (by timeout or other impacts) spawn an explosion at the given coords!						if(!bulletFound) {							spawnExplosion(new Point(xmlData.x, xmlData.y));						}					}										if(what == "rank") {						pidx = getPlayerIndex(int(xmlData.i));												var rank:uint = int(xmlData.r);												players[pidx]['rank'] = rank;						if(players[pidx]['tank']) {							players[pidx]['tank'].setRank(rank);						}												updateOverview();					}										if(what == "finish") {						var gameWinnerId:uint = uint(xmlData.i);						var gameWinnerName:String = String(xmlData.n);												gameOver = true;												updateOverview();						showOverview(true);												// stop sending stuff						// show menu - close button					}										break;			}		}				// NET - count the players not dea		private function aliveNetPlayers():uint {			var alive:uint = players.length - 1;						for(var p:uint = 0; p < players.length; p++) {				if(p == playerIndex) continue;				alive -= (players[p]['dead'])?1:0;			}						return alive;		}				// NET - set ready		private function setNetReady(event:MouseEvent):void {			// disable the button and remove the listener			event.target.enabled = false;			event.target.removeEventListener(event.type, arguments.callee);						// send action to the server			var xml:XML = <a>							<t>game</t>							<w>ready</w>						  </a>;						NetController.send(xml);		}				// NET - show menu		private function showNetMenu(netMenuState:String = "waitForReady"):void {			removeNetMenu();						switch(netMenuState) {				case "waitForReady":					netMenu = Sprite(addChild(getSprite("wndWaitForReady")));					netMenu.name = netMenuState;										Button(netMenu.getChildByName("btnReady")).addEventListener(MouseEvent.CLICK, setNetReady, false, 0, true);										dpPlayerList.removeAll();										var dgPlayersReady:DataGrid = DataGrid(netMenu.getChildByName("dgPlayersReady"));						dgPlayersReady.dataProvider = dpPlayerList;										var playerColumn:DataGridColumn = dgPlayersReady.addColumn("speler");										var readyColumn:DataGridColumn = dgPlayersReady.addColumn("ready");						readyColumn.width = 80;										break;				/*				case "netGameControl":					netMenu = Sprite(addChild(netGameControl));					break;				*/			}						netMenu.x = stage.stageWidth / 2.0;			netMenu.y = stage.stageHeight / 2.0;		}				// NET - clear menu		private function removeNetMenu(event:MouseEvent = null):void {			if(netMenu) {				if(contains(netMenu)) {					removeChild(netMenu);				}								netMenu = null;			}		}				// NET - get player index from Id		private function getPlayerIndex(playerId:uint):int {			if(players.length == 1) return 0;						for(var p:uint = 0; p < players.length; p++) {				if(players[p][0] == playerId) {					return p;				}			}			return -1;		}				// NET - Event Listeners		private function addNetEventListeners():void {			NetController.addEventListener(NetEvent.DISCONNECT, cleanUp);			NetController.addEventListener(NetEvent.DATA, parseNetData);		}				private function removeNetEventListeners():void {			NetController.removeEventListener(NetEvent.DISCONNECT, cleanUp);			NetController.removeEventListener(NetEvent.DATA, parseNetData);				}						// GFX - display the enemy health bar above the current mouse target:		private function showEnemyHP(event:MouseEvent):void {			switch(event.type) {				case MouseEvent.MOUSE_MOVE:					if(!enemyHP) {						enemyHP = Sprite(addChild(getSprite("HPenemy")));												// place just below the HUD						swapChildren(HUD, enemyHP);					}										enemyHPTank = event.target.parent;					updateEnemyHP();					break;			}		}				// GFX - update the enemy health bar		private function updateEnemyHP():void {			if(enemyHP && enemyHPTank) {				enemyHP.x = enemyHPTank.x + 10 - GameCamera.x;				enemyHP.y = enemyHPTank.y - 10 - GameCamera.y - enemyHPTank.height / 2.0;								Sprite(Sprite(enemyHP.getChildByName("HPmeter")).getChildByName("HPleft")).scaleX = (1 / enemyHPTank.maxHP) * enemyHPTank.HP;				TextField(Sprite(enemyHP.getChildByName("HPmeter")).getChildByName("HPtext")).text = enemyHPTank.HP + "/" + enemyHPTank.maxHP;			}		}				// GFX - spawn explosion at point		public function spawnExplosion(position:Point):void {			if(players.length == 0) return;						// spawn below HUD and enemy HP bars			addChildAt(new Explosion(position), getChildIndex(HUD) - players.length);						var player:IGameObject = IGameObject(players[playerIndex]['tank']);						var surround:Array = calculateSurround(new Point(player.x, player.y), position);			Audio.playSound("explosion.mp3", surround['volume'], surround['panning']);		}				// GFX - create button (for menu)		private function createButton(target:Sprite, callback:Function):void {			target.addEventListener(MouseEvent.MOUSE_UP, callback, false, 0, true);			target.buttonMode = true;			target.useHandCursor = true;		}				private function removeButton(target:Sprite, callback:Function):void {			target.removeEventListener(MouseEvent.MOUSE_UP, callback);			target.buttonMode = false;			target.useHandCursor = false;		}				// CORE - resize the playfield when somebody likes to fuck with the resolution..		override protected function updateCameraSize(event:Event = null):void {			if(event) {				super.updateCameraSize(event);			} else {				super.updateCameraSize();			}						if(!GameCamera) return;						if(pauseField && stage) {				// zero-centered				pauseField.x = GameCamera.width / 2.0;				pauseField.y = GameCamera.height / 2.0;			}						if(HUD) {				HUD.x = GameCamera.width / 2.0 - HUD.width / 2.0;				HUD.y = GameCamera.height - HUD.height;			}						if(currentMenu) {				currentMenu.x = (GameCamera.width / 2.0) - (currentMenu.width / 2.0);				currentMenu.y = (GameCamera.height / 2.0) - (currentMenu.height / 2.0);								if(currentMenu.name == "menuMain") {					currentMenu.y -= 33;				}			}						if(netMenu && stage) {				netMenu.x = stage.stageWidth / 2.0;				netMenu.y = stage.stageHeight / 2.0;			}		}	}}
package com.moorscode.net {		import flash.net.XMLSocket;	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.events.IOErrorEvent;	import flash.events.SecurityErrorEvent;	import flash.events.DataEvent;	import flash.utils.Timer;	import flash.utils.getTimer;	public class NetController {		private static var xmlSocket:XMLSocket = new XMLSocket();				private static var server:String = "";		private static var port:int = 0;				private static var sendQueue:Array = new Array();		private static var sendQueueTimer:Timer;				public static var ping:int = 0;		private static var pingTime:int;		private static var pingDelaySeconds:int = 10;		private static var pingTimer:Timer;		private static var serverTimeOffset:Number = 0;				private static var initialized:Boolean = false;				private static var dispatcher:EventDispatcher = new EventDispatcher();				private static var retryCount:uint = 0;		public static var retryLimit:uint = 5;		public static var retryDelay:uint = 3000;		private static var retryTimer:Timer;				public function NetController():void {		}				public static function initialize():void {			xmlSocket.addEventListener(DataEvent.DATA, parseData);			xmlSocket.addEventListener(Event.CONNECT, xmlEvent);			xmlSocket.addEventListener(Event.CLOSE, xmlEvent);			xmlSocket.addEventListener(IOErrorEvent.IO_ERROR, xmlEvent);			xmlSocket.addEventListener(SecurityErrorEvent.SECURITY_ERROR, xmlEvent);						initialized = true;		}				public static function connect(server:String, port:int = 4041):void {			if(!initialized) initialize();						trace('Connecting to: ' + server + ':' + port);						NetController.server = server;			NetController.port = port;						xmlSocket.timeout = 2000; // x milli-seconds before unable to connect.			xmlSocket.connect(server, port);		}				public static function push(data:String):void {			if(xmlSocket.connected) {				xmlSocket.send(data);			} else {				sendQueue.push(data);			}		}				// NET - Send XML to Server (queued or not)		public static function send(xml:XML, forceNoDelay:Boolean = false):void {			if(!xmlSocket.connected) {				xmlSocket.connect(NetController.server, NetController.port);				sendQueue.push(xml);				return;			}						// using the sendQueue keeps from spamming the server:			if(forceNoDelay) {				xmlSocket.send(xml);			} else {				sendQueue.push(xml);			}		}				private static function handleSendQueue(event:TimerEvent):void {			if(sendQueue.length > 0) {				if(xmlSocket.connected) {					xmlSocket.send(sendQueue[0]);					sendQueue.shift();				} else {					sendQueue = new Array();				}			}		}				private static function doPing(event:TimerEvent = null):void {			if(xmlSocket.connected) {				pingTime = getTimer();				xmlSocket.send("PING");			} else {				ping = -1;			}		}				private static function parseData(event:DataEvent):void {			if(event.data == "PONG") {				ping = (getTimer() - pingTime);				dispatcher.dispatchEvent(new NetEvent(NetEvent.PING));				return;			}						var xmlData:XML = new XML(event.data);			/*			if(xmlData.st) {				var date:Date = new Date();				var serverTime = Number(xmlData.st) - (ping / 2.0); // calculate only 1 way ping!				serverTimeOffset = 0; //(date.getTime() / 1000) - serverTime;			}			*/						var dataEvent:NetEvent = new NetEvent(NetEvent.DATA);			dataEvent.xml = xmlData;						dispatcher.dispatchEvent(dataEvent);		}				public static function time():Number {			var date:Date = new Date();			return Math.round(date.getTime() / 1000) - serverTimeOffset;		}				public static function get connected():Boolean {			return xmlSocket.connected;		}						// NET - Event Handler (Connect, Disconnect, IO / Security Error)		private static function xmlEvent(event:Event):void {			switch(event.type) {				case Event.CONNECT:					if(retryTimer) {						if(retryTimer.running) {							retryTimer.stop();						}						retryTimer.removeEventListener(event.type, arguments.callee);						retryTimer = null;					}									sendQueueTimer = new Timer(250);					sendQueueTimer.addEventListener(TimerEvent.TIMER, handleSendQueue);					sendQueueTimer.start();										pingTimer = new Timer(pingDelaySeconds * 1000);					pingTimer.addEventListener(TimerEvent.TIMER, doPing);					pingTimer.start();										doPing();										dispatcher.dispatchEvent(new NetEvent(NetEvent.CONNECT));					break;				case Event.CLOSE:					if(pingTimer) {						if(pingTimer.running) {							pingTimer.stop();						}												pingTimer.removeEventListener(TimerEvent.TIMER, doPing);						pingTimer = null;					}										if(sendQueueTimer) {						if(sendQueueTimer.running) {							sendQueueTimer.stop();						}												sendQueueTimer.removeEventListener(TimerEvent.TIMER, handleSendQueue);						sendQueueTimer = null;					}										sendQueue = new Array();										dispatcher.dispatchEvent(new NetEvent(NetEvent.DISCONNECT));										if(retryLimit > 0) {						retryCount = 0;						retryTimer = new Timer(retryDelay);						retryTimer.addEventListener(TimerEvent.TIMER, reconnect);						retryTimer.start();					}										break;				case IOErrorEvent.IO_ERROR:					trace("Failed to connect: IO_ERROR");					if(!retryTimer && retryLimit > 0) {						retryCount = 0;						retryTimer = new Timer(retryDelay);						retryTimer.addEventListener(TimerEvent.TIMER, reconnect);						retryTimer.start();					}				case SecurityErrorEvent.SECURITY_ERROR:					dispatcher.dispatchEvent(new NetEvent(NetEvent.ERROR));					break;			}		}				private static function reconnect(event:TimerEvent):void {			retryCount++;						if(retryCount >= retryLimit || xmlSocket.connected) {				retryTimer.stop();				retryTimer.removeEventListener(event.type, arguments.callee);				retryTimer = null;								trace('Giving up reconnecting after ' + retryCount + ' tries.');								return;			}						trace('Reconnecting attempt #' + retryCount);						if(server != "") {				connect(server, port);			}		}				public static function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = true) {			dispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);		}		public static function removeEventListener(type:String, listener:Function, useCapture:Boolean = false) {			dispatcher.removeEventListener(type, listener, useCapture);		}	}}
package com.moorscode.rupsbandjenooitgenoeg {	import flash.display.Sprite;	import flash.display.MovieClip;		import flash.geom.Point;		import flash.utils.getTimer;		import com.moorscode.net.NetController;	import com.moorscode.net.NetEvent;		import com.moorscode.game.GameObjectEvent;		public class NetPlayerTank extends Tank {		private var lastUpdate:uint;				public function NetPlayerTank(playerId:int, rank:int = 0):void {			super(null, 10, true);						totalHitpoints = hitpoints = 10;						accelerateSpeed = 0.07;			turnSpeed = 4;			shootingRange = 160;						turretTurnSpeed = 5;			targetTurretDirection = turretDirection = 0;						updateAudio(0.6, 0);						occlusion = false;			this.playerId = playerId;						setRank(rank);						lastUpdate = getTimer();						NetController.addEventListener(NetEvent.DATA, handleData, false, 0, true);		}				private function handleData(event:NetEvent):void {			var xmlData:XML = event.xml;						// only do stuff for me!			var what = xmlData.w;			var tickTime:Number = 25 / 1000;						/* TRANSFER TO NETPLAYERTANK */			if(what == "player") {				if(playerId == int(xmlData.i)) {					setPosition(new Point(Number(xmlData.p.x), Number(xmlData.p.y)));					this.rotation = Number(xmlData.rot);					this.HP = xmlData.hp;										var acc:int = int(xmlData.acc);					switch(acc) {						case 1:							accelerate();							break;						case -1:							decelerate();							break;						case 0:							stationary();							break;					}									this.turretRotation = xmlData.trd;					this.turrentTargetRotation = xmlData.trtd;										/*					if(parent) {						tickTime = rupsbandjenooitgenoeg(parent).tickTime / 1000;					}										// compensate delay from client1 -> server -> client2					var fforward:int = Math.floor((NetController.time() - xmlData.time) / tickTime);					if(fforward > 0) {						trace("fast-forwarding: " + fforward + " times");						for(var f:uint = 0; f < fforward; f++) {							if(parent) {								rupsbandjenooitgenoeg(parent).updateBullets();								tick();							}						}					}					*/										// trace(getTimer() - lastUpdate + ' since last update');					lastUpdate = getTimer();										updateGfx();				}			}						if(what == "shoot") {				if(playerId == int(xmlData.i)) {										if(parent) {						tickTime = rupsbandjenooitgenoeg(parent).tickTime / 1000;					}										var shootEvent:GameObjectEvent = new GameObjectEvent(GameObjectEvent.SHOOT);						shootEvent.targetObject = this;						shootEvent.origin = new Point(xmlData.p.x, xmlData.p.y);						shootEvent.rotation = xmlData.r;						shootEvent.speed = xmlData.s;						shootEvent.ownerId = playerId;						shootEvent.bulletId = int(xmlData.bid);						shootEvent.fforward = 0; //Math.floor((NetController.time() - xmlData.time) / tickTime);										dispatchEvent(shootEvent);				}			}						if(what == "remove") {				if(playerId == int(xmlData.i)) {					alive = false;										var removeEvent:GameObjectEvent = new GameObjectEvent(GameObjectEvent.REMOVE);						removeEvent.ownerId = playerId;										dispatchEvent(removeEvent);										unload();				}			}						if(what == "died") {				if(playerId == int(xmlData.i)) {					alive = false;										var deathEvent:GameObjectEvent = new GameObjectEvent(GameObjectEvent.DESTROYED);						deathEvent.targetObject = this;						deathEvent.ownerId = playerId;										dispatchEvent(deathEvent);										unload();				}			}		}				public function set HP(value:uint):void {			hitpoints = value;						if(hitpoints == 0) {				die();			}		}				public override function hit():void {			// hitpoints--;			// don't check for 0 HP, wait for server to dispatch DEATH event		}				public override function set rotation(newRotation:Number):void {			if(!isNaN(newRotation)) {				super.rotation = targetRotation = newRotation;			}		}	}}
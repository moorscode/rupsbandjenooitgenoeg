package {	// imports!	import flash.display.*;	import flash.text.TextField;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.events.KeyboardEvent;	import flash.media.SoundChannel;	import flash.utils.Timer;	import flash.utils.getTimer;		import flash.geom.Point;	import flash.geom.Rectangle;		import flash.net.SharedObject;		import flash.external.ExternalInterface;		import fl.data.DataProvider;	import fl.controls.DataGrid;	import fl.controls.dataGridClasses.DataGridColumn;	import fl.controls.Button;	import fl.controls.CheckBox;	import fl.controls.TileList;		import com.moorscode.game.GameObjectEvent;	import com.moorscode.game.IGameObject;	import com.moorscode.game.GameCamera;	import com.moorscode.game.GameObjectList;	import com.moorscode.game.GameSkeleton;	import com.moorscode.game.GameEvent;	import com.moorscode.game.GameBackgroundManager;		import com.moorscode.input.Input;	import com.moorscode.sound.Audio;		import com.moorscode.net.NetController;	import com.moorscode.net.NetEvent;	import com.moorscode.rupsbandjenooitgenoeg.Bullet;	import com.moorscode.rupsbandjenooitgenoeg.Tank;	import com.moorscode.rupsbandjenooitgenoeg.PlayerTank;	import com.moorscode.rupsbandjenooitgenoeg.EnemyTank;	import com.moorscode.rupsbandjenooitgenoeg.NetPlayerTank;	import com.moorscode.rupsbandjenooitgenoeg.Tree;	import com.moorscode.rupsbandjenooitgenoeg.TankCorpse;	import com.moorscode.rupsbandjenooitgenoeg.Explosion;		import com.moorscode.particles.*;		import com.moorscode.interfaces.LevelSelectRenderer;		import com.everydayflash.equalizer.*;	import com.everydayflash.equalizer.color.*;		import com.lifeztream.debug.FPS;		public class rupsbandjenooitgenoeg extends GameSkeleton {		private var nextLevel:uint = 1;		private var pauseField:Sprite;		private var HUD:Sprite;				private var enemyHP:Sprite;		private var enemyHPTank:EnemyTank;				private var levelMusic:SoundChannel;		private var menuMusic:SoundChannel;				private var currentMenu:Sprite;		private var menuTimer:Timer;				private var playerId:int = 0;		private var gameOwner:Boolean = false;		private var singlePlayer:Boolean = true;				private var netMenu:Sprite;				private var enemyPlayers:uint = 0;		private var dpPlayerList:DataProvider = new DataProvider();				private var players:Array;		private var playerIndex:uint = 0;		private var followIndex:uint = 0;				private var gameWinnerIndex:int = -1;		private var gameWinnerName:String = "";				private var wonTheGame:Boolean = false;				private var gameOver:Boolean = false;		private var netGameControl:Sprite;				private var lastNetUpdate:uint = 0;		private var lastSendPlayerInfo:XML;		//		private var bgManager:GameBackgroundManager;				private var equalizer:Equalizer;		private var equalizerTimer:Timer = new Timer(30, 0);		private var equalizerSettings:EqualizerSettings;				// constructor; variables will be filled when in MP, otherwise empty		public function rupsbandjenooitgenoeg(players:Array = null, playerId:int = 0, gameOwner:Boolean = false):void {			this.gameOwner = gameOwner;			this.playerId = playerId;			this.players = (players == null)?new Array(new Array(0)):players;						enemyPlayers = this.players.length - 1;			singlePlayer = Boolean(this.players.length == 1 || !NetController.connected);						gameOver = false;						Audio.initialize();						if(!singlePlayer) {				addNetEventListeners();				playerIndex = getPlayerIndex(playerId);				followIndex = playerIndex;				pauseOnBlur = false;				pauseDisabled = true;			}						/*			var fps:FPS = new FPS("left");			addChild(fps);			*/						// add event listeners			addEventListener(GameEvent.LOADED, loadComplete);						addEventListener(GameEvent.PAUSED, handlePause);			addEventListener(GameEvent.UNPAUSED, handlePause);						addEventListener(GameEvent.TICK, tick);			addEventListener(GameEvent.FRAME, frame);						addEventListener(GameEvent.ENDED, finishLevel);		}				// INIT - initialize - after Library is loaded - MP Select Level		private function loadComplete(event:Event):void {			equalizerSettings = new EqualizerSettings();			equalizerSettings.numOfBars = 32;			equalizerSettings.height = stage.stageHeight * 0.75;			equalizerSettings.barSize = stage.stageWidth / equalizerSettings.numOfBars;			equalizerSettings.vgrid = true;			equalizerSettings.hgrid = 2;			equalizerSettings.colorManager = new GradientBarColor(); // 0xffff4444			equalizerSettings.effect = EqualizerSettings.FX_REFLECTION;						equalizer = new Equalizer(equalizerSettings);			equalizerTimer.addEventListener(TimerEvent.TIMER, equalizer.render);						pauseField = getSprite("pauseField");			pauseField.name = "pauseField";			pauseField.x = stage.stageWidth / 2.0;			pauseField.y = stage.stageHeight / 2.0;						// laat menu zien - if singleplayer!			if(singlePlayer) {				showMenu("menuMain");				ExternalInterface.addCallback("playSound", JSSoundRequest);			} else {				netSelectLevel();			}		}				// SOUND - Javascript sound request - play sound		private function JSSoundRequest(sound:String):void {			// only play sounds when in menu.			if(currentMenu) {				Audio.forcePlaySound(sound+".mp3");			}		}				// NET - select level and start it		private function netSelectLevel():void {			// prepare game controls			netGameControl = getSprite("wndGameControl");						// initialize buttons			Button(netGameControl.getChildByName("btnResume")).addEventListener(MouseEvent.CLICK, removeNetMenu);			Button(netGameControl.getChildByName("btnQuit")).addEventListener(MouseEvent.CLICK, cleanUp);						// if gameOwner, select mp level			if(gameOwner) {				var done:Boolean = false;				var i:uint = 0;				var levelTest:Sprite;				var positions:uint = 0;				var eligableLevels = new Array();								// count: mpStartPosition's				while(!done) {					i++;					try {						levelTest = getSprite("level" + i);												var children:uint = levelTest.numChildren;						for(var c:uint = 0; c < children; c++) {							var child = levelTest.getChildAt(c);							positions += (getLogicalClassName(child) == "mpStartPosition")?1:0;						}												if(positions > enemyPlayers) {							eligableLevels.push(new Array(i, positions));						}					} catch(e:Error) {						done = true;					}				}								var loadLevel = Math.round(Math.random() * (eligableLevels.length-1));					nextLevel = eligableLevels[loadLevel][0];								var xml:XML = <a>								<t>game</t>								<w>level</w>								<n>{eligableLevels[loadLevel][0]}</n>								<s>{eligableLevels[loadLevel][1]}</s>							  </a>;								NetController.send(xml);			} else {				// request level info + start position				var xml:XML = <a>								<t>game</t>								<w>loaded</w>							  </a>;								NetController.send(xml);			}		}				// SP - menu		private function showMenu(menu:String):void {			cleanUpMenu(true);									JavaScript("leavingGame");						if(!menuMusic && Audio.musicVolume > 0.0) {				menuMusic = Audio.playMusic("menuMusic.mp3", true, 0.7);			}						currentMenu = Sprite(addChild(getSprite(menu)));			currentMenu.x = GameCamera.width / 2.0 - (currentMenu.width / 2.0);			currentMenu.y = stage.stageHeight / 2.0 - (currentMenu.height / 2.0);									switch(menu) {				case "menuMain":					currentMenu.x = 0;					currentMenu.y = 0;										// convert button to action					createButton(Sprite(currentMenu.getChildByName("btnStart")), startNextLevel);										// control the music checkbox					var toggleMusic:CheckBox = CheckBox(currentMenu.getChildByName("toggleMusic"));						toggleMusic.addEventListener(MouseEvent.CLICK, handleMusic, false, 0, true);						toggleMusic.selected = (Audio.musicVolume > 0.0);										if(toggleMusic.selected) {						addChildAt(equalizer, 0);						equalizerTimer.start();					}										// initialize the level selector					var lastCompletedLevel:uint = 0;										/** MOVE THIS TO INITIALIZE - LOAD FROM DATABASE! **/					// load the last played level from the saved settings					var so:SharedObject = SharedObject.getLocal("settings");					if(so.data.levelComplete) {						lastCompletedLevel = uint(so.data.levelComplete);						nextLevel = lastCompletedLevel;					}										var levelSelect:TileList = TileList(currentMenu.getChildByName("levelSelect"));					levelSelect.setStyle("cellRenderer", LevelSelectRenderer);					var checkLevel:uint = 1;										// fill the level-select tile list					var done:Boolean = false;					while(!done) {						try {							var level:Sprite = getSprite("level" + checkLevel);							levelSelect.addItem({label:"level " + checkLevel, scaleContent:false});														// set all but last level as 'completed'							if(checkLevel <= lastCompletedLevel) {								var previousItem:Object = levelSelect.getItemAt(levelSelect.length-1);								previousItem.source = "assets/html/images/done.gif";							}						} catch(e:Error) {							done = true;						}												done = done || (checkLevel == lastCompletedLevel + 1);						checkLevel++;					}										levelSelect.selectedIndex = levelSelect.length-1;										break;								case "menuFinalVictory":				case "menuVictory":				case "menuDefeated":										var delayTime:int = (menu == "menuFinalVictory")?6000:2000;										// show the screen for 2 seconds, then return					menuTimer = new Timer(delayTime, 1);										menuTimer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent = null) {						event.target.stop();						event.target.removeEventListener(event.type, arguments.callee);												showMenu("menuMain");					});										menuTimer.start();										// get the achievement!					if(menu == "menuFinalVictory") {						var so:SharedObject = SharedObject.getLocal("settings");						if(!so.data.spAchievement) {							so.data.spAchievement = JavaScript("tellChat", "f7c1d52751cb33c51796ce57d572c022");							so.flush();						}					}										break;			}		}				private function cleanUpMenu(stopAudio:Boolean = false):void {						// if a menu is shown, remove it			if(currentMenu) {				if(currentMenu.getChildByName("btnStart")) {					removeButton(Sprite(currentMenu.getChildByName("btnStart")), startNextLevel);				}								removeChild(currentMenu);				currentMenu = null;			}						if(menuMusic && !stopAudio) {				menuMusic.stop();				menuMusic = null;			}						if(contains(equalizer)) {				removeChild(equalizer);			}						if(equalizerTimer.running) {				equalizerTimer.stop();			}		}				private function handleMusic(event:Event):void {			var music:CheckBox = CheckBox(event.target);						var so:SharedObject = SharedObject.getLocal("settings");				so.data.playMusic = music.selected;				so.flush();			if(!music.selected) {				Audio.musicVolume = 0.0;								if(equalizerTimer.running) {					equalizerTimer.stop();				}								if(contains(equalizer)) {					removeChild(equalizer);				}			} else {				Audio.musicVolume = 1.0;								menuMusic = Audio.playMusic("menuMusic.mp3", true, 0.7);				equalizerTimer.start();								if(!contains(equalizer)) {					addChildAt(equalizer, 0);				}			}		}				// GAME - initialize and start the game		private function startLevel(netGame:Boolean = false):void {			var level:Sprite;						nextLevel = Math.max(nextLevel, 1); // minimum level = 1, not 0						try {				level = getSprite("level" + nextLevel);			} catch(e:Error) {				nextLevel--;				startLevel();				return;			}						var p:uint = 0;			for(p = 0; p < players.length; p++) {				if(p == playerIndex) {					players[p]['tank'] = new PlayerTank( players[p][0], players[p]['rank'] );				} else {					players[p]['tank'] = new NetPlayerTank( players[p][0], players[p]['rank'] );					players[p]['HP'] = Sprite(addChild(getSprite("HPenemy")));					TextField(players[p]['HP'].getChildByName("EnemyName")).text = players[p][1];										players[p]['tank'].addEventListener(GameObjectEvent.REMOVE, removeNetPlayer);				}								players[p]['dead'] = false;				players[p]['tank'].addEventListener(GameObjectEvent.SHOOT, fireBullet);				players[p]['tank'].addEventListener(GameObjectEvent.DESTROYED, handleDeath);								addChild(players[p]['tank']);								players[p]['tank'].setRank(players[p]['rank']);			}						followIndex = playerIndex;						placeObjects(level);			level = null;						levelMusic = Audio.playMusic("levelMusic.mp3", true, 0.7);						HUD = Sprite(addChild(getSprite("HUD")));			HUD.y = GameCamera.height;			HUD.x = GameCamera.width / 2.0 - HUD.width / 2.0;						var totalTanks:Array = GameObjectList.getAll("EnemyTank");			TextField(HUD.getChildByName("tanksLeft")).text = "" + ((singlePlayer)?totalTanks.length:aliveNetPlayers());						// addChildAt(bgManager, 0);						// maintain proper z-indexing			setChildIndex(HUD, numChildren - 1);						if(players.length > 1) {				for(p = 0; p < players.length; p++) {					if(p != playerIndex) {						setChildIndex(players[p]['HP'], getChildIndex(HUD) - 1);					}				}								setChildIndex(players[playerIndex]['tank'], getChildIndex(HUD) - players.length);								for(p = 0; p < players.length; p++) {					if(p != playerIndex) {						setChildIndex(players[p]['tank'], getChildIndex(players[playerIndex]['tank']) - 1);					}				}			}						var treeList:Array = GameObjectList.getAll("Tree");			for(var t:uint = 0; t < treeList.length; t++) {				setChildIndex(treeList[t], getChildIndex(HUD) - players.length);			}						if(netGame) {				showNetMenu();			} else {				startGame();			}		}				// NET - start game		private function netStartLevel():void {			removeNetMenu();			startGame();		}				// GAME - start the next level		private function startNextLevel(event:Event = null) {			cleanUpMenu();						if(event != null) {				var levelSelect:TileList = TileList(Sprite(event.target.parent).getChildByName("levelSelect"));				nextLevel = levelSelect.selectedIndex + 1;			}						startLevel();		}				// GAME - at completion of the level		private function finishLevel(event:Event = null):void {			Input.clearInput();						levelMusic.stop();			levelMusic = null;						players[playerIndex]['tank'].removeEventListener(GameObjectEvent.SHOOT, fireBullet);			players[playerIndex]['tank'].removeEventListener(GameObjectEvent.DESTROYED, handleDeath);			players[playerIndex]['tank'] = null;						if(!singlePlayer) {				while(players.length > 0) {					if(players[0]['tank']) {						players[0]['tank'].removeEventListener(GameObjectEvent.SHOOT, fireBullet);						players[0]['tank'].removeEventListener(GameObjectEvent.DESTROYED, handleDeath);												if(players[0]['tank'].hasEventListener(GameObjectEvent.REMOVE)) {							players[0]['tank'].removeEventListener(GameObjectEvent.REMOVE, removeNetPlayer);						}												players[0]['tank'] = null;						players[0]['HP'] = null;						players[0]['dead'] = null;					}										players.shift();				}			}						if(enemyHP && contains(enemyHP)) {				removeChild(enemyHP);			}						//bgManager = null;			enemyHP = null;			enemyHPTank = null;						/* remove HUD */			if(HUD && contains(HUD)) {				removeChild(HUD);			}						if(!singlePlayer) return;						if(wonTheGame == true) {				var so:SharedObject = SharedObject.getLocal("settings");				if(!so.data.levelComplete || uint(so.data.levelComplete) < nextLevel) {					so.data.levelComplete = nextLevel;					so.flush(); // writes changes to disk				}								nextLevel++;								// test to see if this was the last level..				// if the next level can't be loaded, show the final victory screen				try {					var test:Sprite = getSprite("level" + nextLevel);					showMenu("menuVictory");				} catch(e:Error) {					showMenu("menuFinalVictory");				}			} else {				showMenu("menuDefeated");			}		}				private function removeNetPlayer(event:GameObjectEvent):void {			var pidx:uint = getPlayerIndex(event.ownerId);						if(players[pidx]) {				if(players[pidx]['tank']) {					players[pidx]['tank'].removeEventListener(GameObjectEvent.SHOOT, fireBullet);					players[pidx]['tank'].removeEventListener(GameObjectEvent.DESTROYED, handleDeath);										if(players[pidx]['tank'].hasEventListener(GameObjectEvent.REMOVE)) {						players[pidx]['tank'].removeEventListener(GameObjectEvent.REMOVE, removeNetPlayer);					}										players[pidx]['tank'] = null;				}								if(contains(players[pidx]['HP'])) {					removeChild(players[pidx]['HP']);				}								players[pidx]['HP'] = null;				players[pidx]['dead'] = null;								players.splice(pidx, 1);			}						TextField(HUD.getChildByName("tanksLeft")).text = "" + aliveNetPlayers();		}				// GAME - clean up before closing		private function cleanUp(event:* = null):void {			removeNetEventListeners();			removeNetMenu();						cleanUpMenu();						endGame();						if(!singlePlayer) {				gameOver = true;				var xml:XML = <a>								<t>game</t>								<w>leave</w>							  </a>;								NetController.send(xml, true);								dispatchEvent(new Event(Event.CLOSE));			}		}		// INIT: Place Objects - convert the template to the game		private function placeObjects(template:Sprite):void {			var startPosition:uint = 0;			// go through all objects and replace!			var children:uint = template.numChildren;			for(var c:uint = 0; c < children; c++) {				var child = template.getChildAt(0);				var position:Point = new Point(DisplayObject(child).x, DisplayObject(child).y);								switch(getLogicalClassName(child)) {					case "TankHolder":						if(singlePlayer) {							createEnemy("EnemyTank", position);						}						break;					case "TreeHolder":						createEnemy("Tree", position);						break;					case "mpStartPosition":						if(!singlePlayer) {							for(var p:uint = 0; p < players.length; p++) {								if(players[p]['position'] == startPosition) {									var player:Tank = Tank(players[p]['tank']);									player.setPosition(position);								}							}							startPosition++;						}						break;				}								template.removeChild(child);			}		}				// GFX - physically add the enemy to the stage		private function createEnemy(type:String, position:Point):void {			switch(type) {				case "EnemyTank":					var enemy:EnemyTank = new EnemyTank(position)					enemy.addEventListener(GameObjectEvent.DESTROYED, handleDeath);					enemy.addEventListener(GameObjectEvent.SHOOT, fireBullet);					enemy.addEventListener(MouseEvent.MOUSE_MOVE, showEnemyHP);					addChildAt(enemy, 0);					break;				case "Tree":					addChild(new Tree(position, getSprite("tree")));					break;			}		}				// INPUT - check for key input and handle accordingly:		private function checkKeys() {			if(Input.keyDown(27) && !singlePlayer && !netMenu) {								TextField(netGameControl.getChildByName("txtGameControl")).text = 'Maak een keuze';				TextField(netGameControl.getChildByName("txtWinner")).text = '';				Button(netGameControl.getChildByName("btnResume")).enabled = true;								showNetMenu("netGameControl");			}						if(Input.keyDown(27) && singlePlayer && !paused) {				togglePause();			}		}				// INPUT - pause / unpause for defocus		private function handlePause(event:Event = null):void {			if(paused) {				// add pause field				addChild(pauseField);			} else {				// remove pause field, if active				if(getChildByName("pauseField")) {					removeChild(pauseField);				}			}		}		// MATH - tick (!!)		public function tick(event:Event = null):void {			// the player is always in the middle of the screen						var center:Tank = Tank(players[followIndex]['tank']);			if(players[followIndex]['dead']) {				var followHP:Number = 0;								for(var p:uint = 0; p < players.length; p++) {					if(!players[p]['dead'] && players[p]['tank'].HP > followHP) {						followIndex = p;						followHP = players[p]['tank'].HP;					}				}								center = Tank(players[followIndex]['tank']);			}						GameCamera.x = center.x;			GameCamera.y = center.y;						// main game tick.			updatePlayers();						// update enemys			updateEnemies();						// update bullets			updateBullets();		}				// GFX - per frame updates		public function frame(event:Event = null):void {			// check for input:			checkKeys();						// HUD/GUI update			for(var p:uint = 0; p < players.length; p++) {				// hud updates (reload timer)				if(p == playerIndex) {					var percentage:Number = (1 / players[p]['tank'].reloadTime) * players[p]['tank'].reloading;						percentage = Math.max(0, 1 - Math.round(percentage * 100) / 100);										var reloadBar:Sprite = Sprite(Sprite(HUD.getChildByName("ReloadTimer")).getChildByName("ReloadLeft"));					if(reloadBar.scaleX != percentage) {						reloadBar.scaleX = percentage;					}				} else {					// update HUD on players - if they are alive..					if(players[p]['tank'].alive) {						players[p]['HP'].x = players[p]['tank'].x + 10 - GameCamera.x;						players[p]['HP'].y = players[p]['tank'].y - 10 - GameCamera.y - (players[p]['tank'].height / 2.0);												var HPMeter:Sprite = Sprite(players[p]['HP'].getChildByName("HPmeter"));							Sprite(HPMeter.getChildByName("HPleft")).scaleX = (1 / players[p]['tank'].maxHP) * players[p]['tank'].HP;							TextField(HPMeter.getChildByName("HPtext")).text = players[p]['tank'].HP + "/" + players[p]['tank'].maxHP;											} else if(players[p]['HP'] != null) { // if dead but HP is showing, remove it..						if(contains(players[p]['HP'])) {							removeChild(players[p]['HP']);						}												players[p]['HP'] = null;					}				}			}						// Update to NET: after all calculations are done.			if(!singlePlayer) {				/* tickTime = time between frames */				if(lastNetUpdate == 0 || lastNetUpdate < getTimer() - Math.max(NetController.ping, tickTime)) {					lastNetUpdate = getTimer();					sendNetUpdates();				}			} else {				updateEnemyHP();			}		}				// MATH - update players		public function updatePlayers():void {			if(players.length == 0) return;						// bounce on trees			var treeList:Array = GameObjectList.getAll("Tree");			for(var t:uint = 0; t < treeList.length; t++) {				bounce(players[playerIndex]['tank'], treeList[t]);			}						// bounce on other players			if(players.length > 1) {				for(var p:uint = 0; p < players.length; p++) {					// bounce on other players:					if(p != playerIndex) {						bounce(players[playerIndex]['tank'], players[p]['tank']);					}				}			}		}				// MATH - update enemy turning / ticking if in screen:		private function updateEnemies():void {			if(players.length == 0) return;						var player:PlayerTank = PlayerTank(players[playerIndex]['tank']);			var enemyTankList:Array = GameObjectList.getAll("EnemyTank");						var playerPosition:Point = new Point(player.x, player.y);						for(var t:uint = 0; t < enemyTankList.length; t++) {				var enemy:EnemyTank = EnemyTank(enemyTankList[t]);								if(enemy.alive) {					if(enemy.inScreen) {						var surround:Array = calculateSurround(playerPosition, new Point(enemy.x, enemy.y));						enemy.updateAudio(surround['volume'], surround['panning']);					}									if(enemy.inRange(playerPosition)) {						enemy.turnTo(playerPosition);						bounce(player, enemy, "rectangular");					}				}			}		}				// MATH - update bullets, movement / collision		public function updateBullets():void {			var explode:Boolean = false;						var bulletList:Array = GameObjectList.getAll("Bullet");			for(var b:uint = 0; b < bulletList.length; b++) {				// check enemies				var enemyTankList:Array = GameObjectList.getAll("EnemyTank");				for(var e:uint = 0; e < enemyTankList.length; e++) {					if(collides(enemyTankList[e], bulletList[b])) {						enemyTankList[e].hit();						explode = true;					}				}								// check bullets				var treeList:Array = GameObjectList.getAll("Tree");				for(var t:uint = 0; t < treeList.length; t++) {					if(collides(treeList[t], bulletList[b])) {						explode = true;					}				}								// check bullets on player - including id + owner				if(players[playerIndex]['tank']) {					var player:Tank = Tank(players[playerIndex]['tank']);					if(collides(player, bulletList[b]) && bulletList[b].owner != players[playerIndex][0]) {												player.hit();												Sprite(Sprite(HUD.getChildByName("HPmeter")).getChildByName("HPleft")).scaleX = (1 / player.maxHP) * player.HP;						TextField(Sprite(HUD.getChildByName("HPmeter")).getChildByName("HPtext")).text = player.HP + "/" + player.maxHP;												explode = true;																	// send bullet hit event to server if multiplayer!						if(!singlePlayer) {							var hitEvent:XML = <a>												<w>hit</w>												<bi>{Bullet(bulletList[b]).toString()}</bi>												<x>{bulletList[b].x}</x>												<y>{bulletList[b].y}</y>												<time>{NetController.time()}</time>											   </a>;														NetController.send(hitEvent);						}					}				}								if(explode && bulletList[b]) {					spawnExplosion(new Point(bulletList[b].x, bulletList[b].y));					bulletList[b].unload();				}			}		}				// GAME - when something fires a bullet		private function fireBullet(event:GameObjectEvent):void {			var origin:Point = event.origin;						if(singlePlayer || event.ownerId == players[playerIndex][0]) {				origin.x += 30 * Math.cos((event.rotation-90) * Math.PI / 180);				origin.y += 30 * Math.sin((event.rotation-90) * Math.PI / 180);			}						var me:IGameObject = IGameObject(players[playerIndex]['tank']);						var surround:Array = calculateSurround(new Point(me.x, me.y), origin);			Audio.playSound("shoot.mp3", surround['volume'], surround['panning']);						var bullet = new Bullet(origin, event.rotation, event.ownerId, event.bulletId);				bullet.addEventListener(GameObjectEvent.DESTROYED, removeBullet);						addChildAt(bullet, getChildIndex(players[playerIndex]['tank'])+1);						/* If this player shoots;			 * Send bullet info to the server			 * send the time the update is send			 */ 			 			if(singlePlayer || event.ownerId != players[playerIndex][0]) return;						var xml:XML = <a>							<t>game</t>							<w>shoot</w>							<p><x>{event.origin.x}</x><y>{event.origin.y}</y></p>							<r>{event.rotation}</r>							<s>{event.speed}</s>							<bid>{bullet.bulletIndex}</bid>							<time>{NetController.time()}</time>						  </a>;						NetController.send(xml, true);		}				// GAME - when something dies		private function handleDeath(event:GameObjectEvent):void {			var totalTanks:Array = GameObjectList.getAll("EnemyTank");			var isEnemy:Boolean = true;						switch(getLogicalClassName(event.targetObject)) {				case "EnemyTank":					TextField(HUD.getChildByName("tanksLeft")).text = "" + totalTanks.length;										if(event.targetObject == enemyHPTank) {						removeChild(enemyHP);						enemyHP = null;						enemyHPTank = null;					}										break;				case "NetPlayerTank":					players[getPlayerIndex(event.ownerId)]['dead'] = true;					TextField(HUD.getChildByName("tanksLeft")).text = "" + aliveNetPlayers();					break;				case "PlayerTank":					isEnemy = false;										if(singlePlayer) {						wonTheGame = false;						endGame();						return;					} else {						var xml:XML = <a>										<t>game</t>										<w>died</w>									  </a>;												NetController.send(xml);												gameOver = true;						players[playerIndex]['dead'] = true;												TextField(netGameControl.getChildByName("txtGameControl")).text = 'Spel afgelopen!';						TextField(netGameControl.getChildByName("txtWinner")).text = 'Je bent dood';						Button(netGameControl.getChildByName("btnResume")).enabled = false;												showNetMenu("netGameControl");					}					break;			}						// only tanks can die, so add a corpse!			addChildAt(new TankCorpse(new Point(event.targetObject.x, event.targetObject.y), event.targetObject.rotation, isEnemy), 0);						if(singlePlayer && totalTanks.length == 0) {				wonTheGame = true;								// end the game				endGame();			}		}				// Remove the bullet		private function removeBullet(event:GameObjectEvent):void {			event.targetObject.removeEventListener(event.type, arguments.callee);						spawnExplosion(event.origin);						var target = event.targetObject;				target.unload();						if(!singlePlayer) {				if(event.ownerId == players[playerIndex][0]) {					// send MISS to server					var xml:XML = <a>									<t>game</t>									<w>miss</w>								  </a>;										NetController.send(xml);				}			}		}						// MATH - player bouncer on proximity:		private function bounce(obj1:IGameObject, obj2:IGameObject, type:String = "radial"):void { 			switch(type) {				case "radial":					var dx:Number = obj2.x - obj1.x;					var dy:Number = obj2.y - obj1.y;					var distance:Number = Math.sqrt(dx*dx + dy*dy);										var radius1:Number = obj1.hitRadius();					var radius2:Number = obj2.hitRadius();										if(radius2 == 0) return;										var totalRadius:Number = radius1 + radius2;										if(distance < totalRadius) {						 obj1.x = obj2.x - dx / distance * totalRadius; 						 obj1.y = obj2.y - dy / distance * totalRadius; 					}										break;									case "rectangular":					var rect1:Rectangle = obj1.hitbox(this);					var rect2:Rectangle = obj2.hitbox(this);										if(rect1.intersects(rect2)) {						// move away... ?						var rect3 = rect1.intersection(rect2);												if(rect3.width < rect3.height) {							if(rect3.x == rect1.x) {								obj1.x += rect3.width;							} else {								obj1.x -= rect3.width;							}						} else {							if(rect3.y == rect1.y) {								obj1.y += rect3.height;							} else {								obj1.y -= rect3.height;							}						}					}										break;			}		}				// NET - handle incoming data		private function parseNetData(event:NetEvent):void {			var xmlData:XML = event.xml;						var p:uint;			var pidx:uint;			var pid:int;						var what:String;			var playerName:String;			var isReady:String;						// request starting position			// show ready button - wait for all players ready			// add event listeners to net controller						switch(String(xmlData.t)) {				case "game":					what = String(xmlData.w);										if(what == "startpos") {						// recieve all positions at once!						nextLevel = int(xmlData.l);												for each(var position:XML in xmlData.ps.p) {							pidx = getPlayerIndex(int(position.i));							players[pidx]['position'] = int(position.pos);						}												// show ready button, show ready for other players						startLevel(true);												dpPlayerList.removeAll();						for(p = 0; p < players.length; p++) {							playerName = (p == playerIndex)?"Jij":players[p][1];							dpPlayerList.addItem({player:playerName, ready:''});						}					}										if(what == "ready") {						pidx = getPlayerIndex(int(xmlData.i));						players[pidx]['ready'] = true;						players[pidx]['rank'] = int(xmlData.r);												if(players[pidx]['tank']) {							players[pidx]['tank'].setRank(int(xmlData.r));						}												dpPlayerList.removeAll();						// dpPlayersList												for(p = 0; p < players.length; p++) {							playerName = (p == playerIndex)?"Jij":players[p][1];							isReady = (players[p]['ready'])?"READY!":"";							dpPlayerList.addItem({player:playerName, ready:isReady});						}					}										if(what == "remove" && !inGame) {						// remove the player from the ready-list						pidx = getPlayerIndex(xmlData.i);						players.splice(pidx, 1);												dpPlayerList.removeAll();						// dpPlayersList												for(p = 0; p < players.length; p++) {							playerName = (p == playerIndex)?"Jij":players[p][1];							isReady = (players[p]['ready'])?"READY!":"";							dpPlayerList.addItem({player:playerName, ready:isReady});						}					}										if(what == "start") {						netStartLevel();					}										if(what == "hit") {						var bid:int = int(xmlData.bid); // bullet id						var oid:int = int(xmlData.oid); // bullet owner id												pid = int(xmlData.i);						pidx = getPlayerIndex(pid); // player index						// players[pidx]['tank'].HP--;												var bulletFound:Boolean = false;												// find the bullet..						var bulletList:Array = GameObjectList.getAll("Bullet");						for(var b:int = 0; b < bulletList.length; b++) {							if(bulletList[b].toString() == ""+oid+"|"+bid+"") {																var destroyBullet:GameObjectEvent = new GameObjectEvent(GameObjectEvent.DESTROYED);									destroyBullet.targetObject = bulletList[b];									destroyBullet.origin = new Point(xmlData.x, xmlData.y);									destroyBullet.ownerId = oid;																removeBullet(destroyBullet);																bulletFound = true;							}						}												// if the bullet has already been removed (by timeout or other impacts) spawn an explosion at the given coords!						if(!bulletFound) {							spawnExplosion(new Point(xmlData.x, xmlData.y));						}					}										if(what == "rank") {						pid = int(xmlData.i);						pidx = getPlayerIndex(pid);												var rank:uint = int(xmlData.r);						players[pidx]['rank'] = rank;												if(players[pidx]['tank']) {							players[pidx]['tank'].setRank(rank);						}					}										if(what == "finish") {						gameWinnerIndex = getPlayerIndex(int(xmlData.i));						gameWinnerName = xmlData.n;												gameOver = true; //!(gameWinnerIndex == playerIndex);												TextField(netGameControl.getChildByName("txtGameControl")).text = 'Spel afgelopen!';						TextField(netGameControl.getChildByName("txtWinner")).text = (gameWinnerIndex == playerIndex)?"jij wint!":gameWinnerName + " wint!";						Button(netGameControl.getChildByName("btnResume")).enabled = false;												// stop sending stuff						// show menu - close button						showNetMenu("netGameControl");					}										break;			}		}				// NET - count the players not dead		private function aliveNetPlayers():uint {			var alive:uint = players.length - 1;						for(var p:uint = 0; p < players.length; p++) {				if(p == playerIndex) continue;				alive -= (players[p]['dead'])?1:0;			}						return alive;		}				// NET - set ready		private function setNetReady(event:MouseEvent):void {			// disable the button and remove the listener			event.target.enabled = false;			event.target.removeEventListener(event.type, arguments.callee);						// send action to the server			var xml:XML = <a>							<t>game</t>							<w>ready</w>						  </a>;						NetController.send(xml);		}				// NET - show menu		private function showNetMenu(netMenuState:String = "waitForReady"):void {			removeNetMenu();						switch(netMenuState) {				case "waitForReady":					netMenu = Sprite(addChild(getSprite("wndWaitForReady")));					netMenu.name = netMenuState;										Button(netMenu.getChildByName("btnReady")).addEventListener(MouseEvent.CLICK, setNetReady, false, 0, true);										dpPlayerList.removeAll();										var dgPlayersReady:DataGrid = DataGrid(netMenu.getChildByName("dgPlayersReady"));						dgPlayersReady.dataProvider = dpPlayerList;										var playerColumn:DataGridColumn = dgPlayersReady.addColumn("player");						playerColumn.width = 140;												dgPlayersReady.addColumn("ready");										break;				case "netGameControl":					netMenu = Sprite(addChild(netGameControl));					break;			}						netMenu.x = stage.stageWidth / 2.0;			netMenu.y = stage.stageHeight / 2.0;		}				// NET - clear menu		private function removeNetMenu(event:MouseEvent = null):void {			if(netMenu) {				if(contains(netMenu)) {					removeChild(netMenu);				}								netMenu = null;			}		}				// NET - send player data to the server		private function sendNetUpdates():void {			if(players.length == 0) return;						// send updates			var player:PlayerTank = PlayerTank(players[playerIndex]['tank']);			var acceleration = (player.accelerating)?1:((player.decelerating)?-1:0);						// create xml to send			var xml:XML = <a>							<t>game</t>							<w>playerinfo</w>							<d>{player.distanceTraveled}</d>							<p><x>{player.x}</x><y>{player.y}</y></p>							<hp>{player.HP}</hp>							<rot>{player.rotation}</rot>							<acc>{acceleration}</acc>							<trd>{player.turretRotation}</trd>							<trtd>{player.turrentTargetRotation}</trtd>							<time>{NetController.time()}</time>						  </a>;						NetController.send(xml, true);						lastNetUpdate = getTimer();		}				// NET - get player index from Id		private function getPlayerIndex(playerId:uint):int {			if(players.length == 1) return 0;						for(var p:uint = 0; p < players.length; p++) {				if(players[p][0] == playerId) {					return p;				}			}			return -1;		}				// NET - Event Listeners		private function addNetEventListeners():void {			NetController.addEventListener(NetEvent.DISCONNECT, cleanUp);			NetController.addEventListener(NetEvent.DATA, parseNetData);		}				private function removeNetEventListeners():void {			NetController.removeEventListener(NetEvent.DISCONNECT, cleanUp);			NetController.removeEventListener(NetEvent.DATA, parseNetData);				}						// GFX - display the enemy health bar above the current mouse target:		private function showEnemyHP(event:MouseEvent):void {			switch(event.type) {				case MouseEvent.MOUSE_MOVE:					if(!enemyHP) {						enemyHP = Sprite(addChild(getSprite("HPenemy")));												// place just below the HUD						swapChildren(HUD, enemyHP);					}										enemyHPTank = event.target.parent;					updateEnemyHP();					break;			}		}				// GFX - update the enemy health bar		private function updateEnemyHP():void {			if(enemyHP && enemyHPTank) {				enemyHP.x = enemyHPTank.x + 10 - GameCamera.x;				enemyHP.y = enemyHPTank.y - 10 - GameCamera.y - enemyHPTank.height / 2.0;								Sprite(Sprite(enemyHP.getChildByName("HPmeter")).getChildByName("HPleft")).scaleX = (1 / enemyHPTank.maxHP) * enemyHPTank.HP;				TextField(Sprite(enemyHP.getChildByName("HPmeter")).getChildByName("HPtext")).text = enemyHPTank.HP + "/" + enemyHPTank.maxHP;			}		}				// GFX - spawn explosion at point		public function spawnExplosion(position:Point):void {			if(players.length == 0) return;						// spawn below HUD and enemy HP bars			addChildAt(new Explosion(position), getChildIndex(HUD) - players.length);						var player:IGameObject = IGameObject(players[playerIndex]['tank']);						var surround:Array = calculateSurround(new Point(player.x, player.y), position);			Audio.playSound("explosion.mp3", surround['volume'], surround['panning']);		}				// GFX - create button (for menu)		private function createButton(target:Sprite, callback:Function):void {			target.addEventListener(MouseEvent.MOUSE_UP, callback, false, 0, true);			target.buttonMode = true;			target.useHandCursor = true;		}				private function removeButton(target:Sprite, callback:Function):void {			target.removeEventListener(MouseEvent.MOUSE_UP, callback);		}				// CORE - resize the playfield when somebody likes to fuck with the resolution..		override protected function updateCameraSize(event:Event = null):void {			if(event) {				super.updateCameraSize(event);			} else {				super.updateCameraSize();			}						if(!GameCamera) return;						if(pauseField && stage) {				// zero-centered				pauseField.x = GameCamera.width / 2.0;				pauseField.y = stage.stageHeight / 2.0;			}						if(HUD) {				HUD.y = GameCamera.height;				HUD.x = GameCamera.width / 2.0 - HUD.width / 2.0;			}						if(netMenu && stage) {				netMenu.x = stage.stageWidth / 2.0;				netMenu.y = stage.stageHeight / 2.0;			}		}	}}
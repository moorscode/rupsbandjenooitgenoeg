package com.moorscode.game {	import flash.display.Sprite;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.events.Event;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.utils.getQualifiedClassName;	import flash.utils.getDefinitionByName;	import flash.utils.getTimer;		import com.moorscode.game.GameObjectEvent;	import com.moorscode.game.GameCamera;		import com.moorscode.game.GameObjectList;		public class IGameObject extends Sprite {		protected 	var shootingRange:Number = 0;		public 		var hasSound:Boolean = false;				public 		var alive:Boolean = true;		public 		var totalHitpoints:int = 1;		protected 	var hitpoints:int = 1;				public 		var speed:Number = 0;		protected 	var maxSpeed:Number = 0;		protected 	var minSpeed:Number = 0;				public 		var accelerating:Boolean = false;		public 		var decelerating:Boolean = false;		protected 	var accelerateSpeed:Number = 0;		protected 	var slowdownSpeed:Number = 0;				protected 	var xVelocity:Number = 0;		protected 	var yVelocity:Number = 0;				protected 	var turnSpeed:Number = 0;		public 		var targetRotation:Number = 0;		public 		var targetPosition:Point = new Point(0,0);				protected	var paused:Boolean = false;				protected 	var _x:Number = 0;		protected 	var _y:Number = 0;		protected 	var _rotation:Number = 0;				protected 	var occlusion:Boolean = true;				public function IGameObject(position:Point = null):void {			if(position != null) {				setPosition(position);			}						hitpoints = totalHitpoints;						GameObjectList.addObject(this);						visible = false;		}				public function setPosition(position:Point):void {			x = position.x;			y = position.y;						updateGfx();		}				public override function get x():Number {			return Math.round(_x * 100) / 100;		}				public override function set x(newX:Number):void {			if(!isNaN(newX)) {				_x = newX;			}		}				public override function get y():Number {			return Math.round(_y * 100) / 100;		}		public override function set y(newY:Number):void {			if(!isNaN(newY)) {				_y = newY;			}		}				public function get velocity():Point {			return new Point(xVelocity, yVelocity);		}				public function get screenX():int {			return super.x;		}				public function get screenY():int {			return super.y;		}				public override function get rotation():Number {			return Math.round(_rotation * 100) / 100;		}				public override function set rotation(newRotation:Number):void {			if(!isNaN(newRotation)) {				_rotation = newRotation;			}		}				public function show():void {			visible = true;		}				public function hide():void {			visible = false;		}				public function pause(paused:Boolean = true):void {			if(paused) mute();			if(!paused) unmute();						this.paused = paused;		}				public function mute():void {		}				public function unmute():void {		}		public function get HP():uint {			return hitpoints;		}				public function get maxHP():uint {			return totalHitpoints;		}				public function get inScreen():Boolean {			var hit:Rectangle = hitbox(parent);				hit.x += GameCamera.x;				hit.y += GameCamera.y;						return Boolean(GameCamera.intersects(hit));		}				public function updateGfx():void {			// if its not added to anything, skip it			if(parent == null) return;						var rotationOffset:Point = new Point(0,0);				rotationOffset.x = Math.cos((GameCamera.rotation+90) * Math.PI / 180);				rotationOffset.y = Math.sin((GameCamera.rotation+90) * Math.PI / 180);			if(Math.abs(super.x + (_x - GameCamera.x)) > 0.5) super.x = Math.round(_x - GameCamera.x); // * rotationOffset.x;			if(Math.abs(super.y + (_y - GameCamera.y)) > 0.5) super.y = Math.round(_y - GameCamera.y); //  * rotationOffset.y;			if(Math.abs(super.rotation + _rotation) > 0.1) super.rotation = _rotation; // - GameCamera.rotation;						if(!visible && inScreen || !occlusion) {				visible = true;			} else if(visible && !inScreen) {				visible = false;			}		}				public function inRange(checkPoint:Point):Boolean {			var dx:Number = checkPoint.x - x;			var dy:Number = checkPoint.y - y;						var distance:Number = Math.sqrt(dx*dx + dy*dy);						var radius1:Number = shootingRange;			var radius2:Number = 30;						var totalRadius:Number = radius1 + radius2;						return (distance < totalRadius);		}				public function hitbox(targetCoordinateSpace:DisplayObject):Rectangle {			return getBounds(targetCoordinateSpace);		}				public function hitRadius():Number {			return (width > height)?width / 2.0:height / 2.0;		}				public function unload():void {			alive = false;						// remove all attached objects.			while(numChildren > 0) {				removeChildAt(0);			}						if(parent && parent.contains(this)) {				parent.removeChild(this);			}						GameObjectList.removeObject(this);		}				public function stationary():void {			decelerating = false;			accelerating = false;		}				public function isStationary():Boolean {			return Boolean(!(decelerating && accelerating));		}				public function accelerate():void {			decelerating = false;			accelerating = true;		}				public function decelerate():void {			decelerating = true;			accelerating = false;		}				public function hit():void {			hitpoints--;						if(hitpoints == 0) {				this.die();			}		}				public function die():void {			alive = false;			// replace by dead-gfx			// trigger sound						var objectDestroyed:GameObjectEvent = new GameObjectEvent(GameObjectEvent.DESTROYED);				objectDestroyed.targetObject = this;						dispatchEvent(objectDestroyed);						decelerate();		}				public function updateAudio(volume:Number, panning:Number):void {			// empty holder		}				public function turnTo(target:Point = null):void {			// empty holder		}				public function turnLeft():void {			targetRotation -= turnSpeed;		}				public function turnRight():void {			targetRotation += turnSpeed;		}						public function tick():void {			if(!alive) return;						if(targetRotation > _rotation) {				_rotation += turnSpeed;			} else if(targetRotation < _rotation) {				_rotation -= turnSpeed;			}						if(accelerating && speed < maxSpeed) {				speed += accelerateSpeed;				if(speed > maxSpeed) {					speed = maxSpeed;				}			}						if(decelerating && speed > minSpeed) {				speed -= accelerateSpeed;				if(speed < minSpeed) {					speed = minSpeed;				}			}						if(!accelerating && !decelerating && speed != 0 ) {				speed *= slowdownSpeed;				if(Math.abs(speed) < 0.05) {					speed = 0;				}			}						// update position.			var xPercentage:Number;			var yPercentage:Number;			var dir:Number;						xVelocity = speed * Math.cos((_rotation-90) * Math.PI / 180);			yVelocity = speed * Math.sin((_rotation-90) * Math.PI / 180);						this._x += xVelocity;			this._y += yVelocity;		}				public override function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0.0, useWeakReference:Boolean = true):void {			super.addEventListener(type, listener, useCapture, priority, useWeakReference);		}				protected function getLogicalClassName(object:*):String {			var className:String = getQualifiedClassName(object);						if(className.indexOf('::') > -1) {				className = className.substr(className.indexOf('::') + 2);			}						return className;		}				protected function getSymbol(symbolName:String):Class {			return getDefinitionByName(symbolName) as Class;		}				public function getMovieClip(symbolName:String):MovieClip {			var classDef:Class = getSymbol(symbolName);			return MovieClip(new classDef());		}				public function getSprite(symbolName:String):Sprite {			var classDef:Class = getSymbol(symbolName);			return Sprite(new classDef());		}		public function getBitmap(symbolName:String):Bitmap {			var classDef:Class = getSymbol(symbolName);			return new Bitmap(new classDef(-1, -1));		}	}}
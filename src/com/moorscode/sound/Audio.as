package com.moorscode.sound {	import flash.media.Sound;	import flash.media.SoundTransform;	import flash.media.SoundChannel;	import flash.media.SoundMixer;		import flash.events.IOErrorEvent;	import flash.events.Event;		import flash.net.URLLoader;	import flash.net.URLRequest;		import flash.external.ExternalInterface;		public class Audio {		public static var path:String 				= "";				private static var __muted:Boolean 			= false;		private static var __mutedMusic:Boolean 	= false;		private static var __mutedEffects:Boolean 	= false;				private static var __globalVolume:Number 	= 1.0;		private static var __musicVolume:Number 	= 1.0;		private static var __fxVolume:Number 		= 1.0;				private static var __musicChannels:Array 	= new Array();		private static var __effectChannels:Array 	= new Array();				private static var __initialized:Boolean 	= false;				public function Audio():void {		}				/** Initialize class: load settings from the database, via PHP **/		public static function initialize():void {			if(__initialized) return;			   __initialized = true;						var url:URLLoader = new URLLoader();				url.addEventListener(Event.COMPLETE, applySettings, false, 0, true);				url.load(new URLRequest("assets/php/config.php"));		}				private static function applySettings(event:Event):void {			event.target.removeEventListener(event.type, arguments.callee);			var xml:XML = XML(event.target.data);						if(xml != '') {				globalVolume 	= Number(xml.volume.global);				musicVolume 	= Number(xml.volume.music);				fxVolume		= Number(xml.volume.fx);			}		}				/** Handle Muting **/		public static function get mute():Boolean {			return __muted;		}				public static function set mute(value:Boolean):void {			__muted = value;						if(__muted) {				SoundMixer.soundTransform = new SoundTransform(0.0, 0);			} else {				SoundMixer.soundTransform = new SoundTransform(__globalVolume, 0);			}						__updateMusicChannels();			__updateEffectChannels();		}				public static function get muteMusic():Boolean {			return __mutedMusic;		}				public static function set muteMusic(value:Boolean):void {			__mutedMusic = value;			__updateMusicChannels();		}				public static function get muteEffects():Boolean {			return __mutedEffects;		}				public static function set muteEffects(value:Boolean):void {			__mutedEffects = value;			__updateEffectChannels();			trace('Audio::effects muted = ' + value);		}						/** Updating of volume levels **/		public static function set globalVolume(value:Number):void {			__globalVolume = value;						if(!__muted) {				SoundMixer.soundTransform = new SoundTransform(__globalVolume, 0);			}		}				public static function get musicVolume():Number {			return __musicVolume;		}				public static function set musicVolume(value:Number):void {			__musicVolume = value;			__updateMusicChannels();			trace('Audio::music = ' + value);		}				public static function get fxVolume():Number {			return __fxVolume;		}				public static function set fxVolume(value:Number):void {			__fxVolume = value;			__updateEffectChannels();						trace('Audio::fx = ' + value);		}				/** Play sound - music or effect **/		public static function playMusic(filename:String, loop:Boolean = true, volume:Number = 1.0):SoundChannel {			if(!__initialized) initialize();						var soundVolume:Number = volume * __musicVolume * ((__muted || __mutedMusic) ? 0 : 1);						var sound:Sound = SoundCache.load("assets/" + path + filename);						var channel:SoundChannel = sound.play(0, (loop)?int.MAX_VALUE:1, new SoundTransform(soundVolume));				channel.addEventListener(Event.SOUND_COMPLETE, __removeMe);						var soundObject:Array = new Array();				soundObject['channel'] = channel;				soundObject['volume'] = volume;						var channelIndex:uint = __musicChannels.push(soundObject) - 1;						return __musicChannels[channelIndex]['channel'];		}				public static function playSound(filename:String, volume:Number = 1.0, panning:Number = 0.0, force:Boolean = false):SoundChannel {			if(!__initialized) initialize();						var soundVolume:Number = volume * __fxVolume * ((__muted || __mutedEffects) ? 0 : 1);						var sound:Sound = SoundCache.load("assets/" + path + filename);						var channel:SoundChannel = sound.play(0, 1, new SoundTransform(soundVolume, panning));				channel.addEventListener(Event.SOUND_COMPLETE, __removeMe);						var soundObject:Array = new Array();				soundObject['channel'] = channel;				soundObject['volume'] = volume;						var channelIndex:uint = __effectChannels.push(soundObject) - 1;						return __effectChannels[channelIndex]['channel'];		}				/** Force at max volume **/		public static function forcePlaySound(filename:String, volume:Number = 1.0):SoundChannel {			SoundMixer.soundTransform = new SoundTransform(1.0, 0);						var channel:SoundChannel = playSound(filename, volume, 0, true);				channel.addEventListener(Event.SOUND_COMPLETE, __restoreVolume);						return channel;		}				/** Update volume / panning of playing sounds **/		public static function volume(target:SoundChannel, volume:Number = 1.0):void {			adjust(target, volume, target.soundTransform.pan);		}				public static function panning(target:SoundChannel, panning:Number = 0.0):void {			target.soundTransform = new SoundTransform(target.soundTransform.volume, panning);		}				public static function adjust(target:SoundChannel, volume:Number = 1.0, panning:Number = 0.0):void {			if(__findIndex(__musicChannels, target) > -1) {				volume *= __musicVolume;				volume = (__mutedMusic) ? 0.0 : volume;			}						if(__findIndex(__effectChannels, target) > -1) {				volume *= __fxVolume;				volume = (__mutedEffects) ? 0.0 : volume;			}						volume = (__muted) ? 0.0 : volume;						if(target) {				target.soundTransform = new SoundTransform(volume, panning);			}		}				private static function __updateMusicChannels():void {			for(var index in __musicChannels) {				volume(__musicChannels[index]['channel'], __musicChannels[index]['volume']);			}		}				private static function __updateEffectChannels(previousVolume:Number = 1.0):void {			for(var index in __effectChannels) {				volume(__effectChannels[index]['channel'], __effectChannels[index]['volume']);			}		}				private static function __restoreVolume(event:Event):void {			SoundMixer.soundTransform = new SoundTransform(__globalVolume, 0);		}				private static function __findIndex(searchIn:Array, channel:*):int {			var index:int = -1;						for(var i:uint = 0; i<searchIn.length; i++) {				if(searchIn[i]['channel'] == channel) {					index = i;					break;				}			}						return index;		}				private static function __removeMe(event:Event):void {			var index:int;						index = __findIndex(__effectChannels, event.target);			if(index > -1) {				__effectChannels.splice(index, 1);				return;			}						index = __findIndex(__musicChannels, event.target);			if(index > -1) {				__musicChannels.splice(index, 1);			}		}				public static function errorHandler(event:IOErrorEvent):void {			trace("Sound couldn't be loaded!");		}	}}
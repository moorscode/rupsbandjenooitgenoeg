//Based on ID3 parsing by benstucki//http://lab.benstucki.net/archives/id3streamexplorer/srcview/index.htmlpackage com.moorscode.sound.mp3 {		import flash.display.Bitmap;	import flash.events.*;	import flash.media.ID3Info;	import flash.utils.ByteArray;	import flash.utils.Endian;		public class ID3Reader extends EventDispatcher {		private var _version			:Number; // ID3 version (major.minor)		private var _length				:int; 	// ID3 tag size in bytes		private var _frames				:Array;// holds all our ID3 frames		private var _bytes				:ByteArray;		private var _img				:ByteArray;		private var _unsynchronisation	:Boolean;		private var _extendedHeader		:Boolean;		private var _experimental		:Boolean;				private var _frameIdSize		:uint = 3;		private var _frameHeadSize		:uint = 10;				private var _id3:ID3;				public function ID3Reader(data:ByteArray) {			_frames = new Array();			_img 	= new ByteArray();			_bytes 	= data;			parse();		}				public function get version():Number { return _version; }		public function get length():int { return _length; }				public function get id3():ID3 { return _id3; }				private function parse():void {						_version = _bytes.readByte() + _bytes.readByte() * 0.01;						if (_version >= 3) { _frameIdSize = 4; }						var flags				:uint = _bytes.readByte();			var unsynchronisation	:uint = flags >> 7;			var extendedHeader		:uint = flags >> 6 && 01;			var experimental		:uint = flags >> 5 && 001;			var footerpresent		:uint = flags >> 4 && 0001;						_length = readSynchsafeIntA(_bytes.readInt());						readFrames();		}				private function readFrames():void {			var id:String = "";			var size:uint = 0;			while(_bytes.position < _length + 10){				id 	 = _bytes.readUTFBytes(_frameIdSize);				size = _bytes.readInt();								if (version >= 3) {					_bytes.readByte();					_bytes.readByte();				}								if(id=="APIC" || id=="PIC"){					_frames[id] = readAPIC(size);					traceObject(_frames[id]);				} else if (id == "GEOB") {					_frames[id] = readGEOB(size);					traceObject(_frames[id]);				} else if (id == "COMM" || id == "USLT") {					//readUnknown(size);					_frames[id] = readTextFrame(size);					traceObject(_frames[id]);				} else if (id == "PRIV") {					_frames[id] = readPRIV(size);					traceObject(_frames[id]);				} else if (id.charAt(0) == "T") {					_frames[id] = readTextFrame(size, id!="TP1");					traceObject(_frames[id]);				} else if (id.charAt(0) == "W") {					readUnknown(size);				} else if (id == "") {					trace("error");					break;				} else {readUnknown(size)};			}						_id3 = new ID3();			_id3.setImage(_img);			_id3.songName 	=  _frames["TIT2"] ? String(_frames["TIT2"].text) : "untitled";			_id3.artist 	=  _frames["TPE1"] ? String(_frames["TPE1"].text) :  _frames["TP1"] ? String(_frames["TP1"].text) : "unknown artist";			_id3.album	 	=  _frames["TALB"] ? String(_frames["TALB"].text) : "unknown album";			_id3.track	 	=  _frames["TRCK"] ? String(_frames["TRCK"].text) : "?/?";			_id3.encoder 	=  _frames["TENC"] ? String(_frames["TENC"].text) : "";			_id3.year	 	=  _frames["TYER"] ? String(_frames["TYER"].text) : "";			_id3.genre		=  _frames["TCON"] ? String(_frames["TCON"].text) : "";			_id3.comment	=  _frames["COMM"] ? String(_frames["COMM"].text) : "";					}				private function readSynchsafeIntA(synch:int):int {			return (synch & 127) + 128 * ((synch >> 8) & 127) + 16384 * ((synch >> 16) & 127) + 2097152 * ((synch >> 24) & 127);		}				private function readPRIV(size:uint):Object {			var start:uint = _bytes.position;			var obj:Object = new Object();			obj.data = new ByteArray();			obj.owner = readString();			if (size-(_bytes.position - start) > 0) _bytes.readBytes(obj.data, 0, size-(_bytes.position - start));			return obj;		}				private function readGEOB(size:uint):Object {			var start:uint = _bytes.position;			var obj:Object = new Object();			obj.data = new ByteArray();			obj.encoding = _bytes.readByte();			obj.mime = readString();			obj.type = _bytes.readByte();			obj.filename = readString();			obj.description = readString();			_bytes.readBytes(obj.data, 0, size-(_bytes.position - start));			obj.data.position = 0;			return obj;		}				private function readUnknown(size:uint):void {			skipLength(size);		}				private function skipLength(x:uint):void {			for (var i:int = 0; i < x; ++i) { _bytes.readByte(); }		}				private function readTextFrame(size:uint, hasEncoding:Boolean = true):Object {			var obj:Object = new Object();			if (hasEncoding) {				obj.encoding = _bytes.readByte();				obj.text = _bytes.readUTFBytes(size-1);			}else {				obj.text = _bytes.readUTFBytes(size);			}			return obj;		}				private function readAPIC(size:uint):Object {			var start:uint = _bytes.position;			var obj:Object = new Object();			obj.data = new ByteArray();			obj.encoding = _bytes.readByte();			obj.mime = readString();			obj.type = _bytes.readByte();			obj.description = readString();			_bytes.readBytes(_img, 0, size-(_bytes.position - start));			_img.position = 0;			return obj;		}				private function readString():String {			var ba:ByteArray = new ByteArray();			var b:int = _bytes.readByte();			while( b!=0 ) {				ba.writeByte(b)				b = _bytes.readByte();			}			ba.position = 0;			return ba.readUTFBytes(ba.length);		}				private function traceObject(obj:Object):void {			for (var s:String in obj) {				trace("     " + s + " : " + obj[s]);			}		}	}}
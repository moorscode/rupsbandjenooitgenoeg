/*** WaveSound by Denis Kolyako. May 28, 2007* Visit http://dev.etcs.ru for documentation, updates and more free code.** You may distribute this class freely, provided it is not modified in any way (including* removing this header or changing the package path).* ** Please contact etc[at]mail.ru prior to distributing modified versions of this class.*//** * The WaveSound class lets you work with sound in an application. * The WaveSound class lets you create a new WaveSound object, load and play an external WAV file into that object, * close the sound stream, and access data about the sound, such as information about the number of bytes in the stream and PCM parameters. * More detailed control of the sound is performed through the sound source — the SoundChannel or Microphone object for the sound — * and through the properties in the SoundTransform class that control the output of the sound to the computer's speakers.  * This class supports 44100, 22050, 11025, 5512.5 sample rates, 8 or 16 bit, 1 or 2 channels (mono/stereo) RIFF (not RIFX) PCM wav-files without any compression. */package com.moorscode.sound.wave {    import flash.display.Loader;    import flash.display.LoaderInfo;    import flash.events.Event;    import flash.events.EventDispatcher;    import flash.events.HTTPStatusEvent;    import flash.events.IOErrorEvent;    import flash.events.ProgressEvent;    import flash.events.SecurityErrorEvent;    import flash.media.Sound;    import flash.media.SoundChannel;    import flash.media.SoundTransform;    import flash.net.URLRequest;    import flash.net.URLStream;    import flash.utils.ByteArray;    import flash.utils.Endian;	import flash.net.FileReference;        import com.moorscode.sound.wave.WaveSoundEvent;        [Event(name="complete", type="flash.events.Event")]    [Event(name="progress", type="flash.events.ProgressEvent")]    [Event(name="open", type="flash.events.Event")]    [Event(name="ioError", type="flash.events.IOErrorEvent")]    [Event(name="httpStatus", type="flash.events.HTTPStatusEvent")]    [Event(name="securityError", type="flash.events.SecurityErrorEvent")]	    public class WaveFileReferenceLoader extends EventDispatcher {        /*        * *********************************************************        * CLASS PROPERTIES        * *********************************************************        *        *///        private var waveData:URLStream;        private var waveHeader:ByteArray;        private var waveFormat:PCMFormat;        private var isLoadStarted:Boolean = false;        private var isLoaded:Boolean = false;        private var __bytesLoaded:uint = 0;        private var __bytesTotal:uint = 0;        private var __length:Number = 0;        private var __url:String;		private var __fileRef:FileReference;		        private var __sound:Sound;        		private var waveData:ByteArray;		        /*        * *********************************************************        * CONSTRUCTOR        * *********************************************************        *        */        /**         * Creates a new WaveSound object. If you pass a valid URLRequest object to the WaveSound constructor,         * the constructor automatically calls the load() function for the Sound object.         * If you do not pass a valid URLRequest object to the WaveSound constructor,         * you must call the load() function for the WaveSound object yourself, or the stream will not load.          *          * Once load() is called on a WaveSound object, you can't later load a different sound file into that WaveSound object.         * To load a different sound file, create a new WaveSound object.         *          * @param stream:URLRequest (default = null) — The URL that points to an external WAV file.          */        public function WaveFileReferenceLoader() {            super();        }				public function loadFromReference(fileRef:FileReference):void {			__fileRef = fileRef;						__fileRef.addEventListener(Event.COMPLETE, loaderCompleteHandler, false, 0, true);			__fileRef.addEventListener(ProgressEvent.PROGRESS, progressHandler, false, 0, true);			__fileRef.load();		}				private function loaderCompleteHandler(event:Event):void {			__fileRef.removeEventListener(Event.COMPLETE, loaderCompleteHandler);			__fileRef.removeEventListener(ProgressEvent.PROGRESS, progressHandler);						waveData = null;			waveData = __fileRef.data as ByteArray;			waveData.endian = Endian.LITTLE_ENDIAN;						completeHandler();		}		        /*        * *********************************************************        * PRIVATE METHODS        * *********************************************************        *        */        private function completeHandler(event:Event = null):void {            waveHeader = new ByteArray();            waveHeader.endian = Endian.LITTLE_ENDIAN;			            waveData.readBytes(waveHeader, 0, PCMFormat.HEADER_SIZE);            waveFormat = new PCMFormat();                        try {                waveFormat.analyzeHeader(waveHeader);            } catch (e:Error) {                trace(e);                dispatchEvent(new WaveSoundEvent(WaveSoundEvent.DECODE_ERROR));                return;            }                        var bytesToRead:uint = Math.min(waveData.bytesAvailable, waveFormat.waveDataLength);            waveData.readBytes(waveData, 0, bytesToRead);			            var swf:SWFFormat = new SWFFormat(waveFormat);            var compiledSWF:ByteArray = swf.compileSWF(waveData);            			var loader:Loader = new Loader();            loader.loadBytes(compiledSWF);            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, generateCompleteHandler);        }				public function get samplerate():Number {			return waveFormat.sampleRate;		}                private function httpStatusHandler(event:HTTPStatusEvent):void {            dispatchEvent(event);            }                private function ioErrorHandler(event:IOErrorEvent):void {            dispatchEvent(event);        }        private function progressHandler(event:ProgressEvent):void {            __bytesLoaded = event.bytesLoaded;            __bytesTotal = event.bytesTotal;			            dispatchEvent(event);        }                private function openHandler(event:Event):void {            dispatchEvent(event);        }        private function securityErrorHandler(event:SecurityErrorEvent):void {            dispatchEvent(event);        }                private function generateCompleteHandler(event:Event):void {            var soundClass:Class = LoaderInfo(event.target).applicationDomain.getDefinition(SWFFormat.CLASS_NAME) as Class;            			__sound = new soundClass() as Sound;            __length = __sound.length;            			isLoaded = true;            dispatchEvent(new Event(Event.COMPLETE));        }                /*        * *********************************************************        * SETTERS/GETTERS        * *********************************************************        *        */        /**         * Returns the currently available number of bytes in this sound object. read-only.         */        public function get bytesLoaded():uint {            return __bytesLoaded;        }                /**         * Returns the total number of bytes in this sound object. read-only.         */        public function get bytesTotal():uint {            return __bytesTotal;        }        /**         * The length of the current sound in milliseconds. read-only.         */        public function get length():Number {            return __length;            }				public function get sound():Sound {			if(isLoaded) {				return __sound;			}						return null;		}                /**         * Returns a copy of audio data (from PCM wave-data) in ByteArray. Returns null if sound was not loaded. read-only.         */        public function get audioData():ByteArray {            if (isLoaded) {                var outData:ByteArray = new ByteArray();                outData.endian = Endian.LITTLE_ENDIAN;                outData.writeBytes(waveData);                return outData;            }                        return null;        }                /**         * Returns a copy of PCMFormat object, which contains some parameters of loaded sound. Returns null if sound was not loaded. read-only.         */        public function get audioFormat():PCMFormat {            if (isLoaded) {                var format:PCMFormat = new PCMFormat();                format.analyzeHeader(waveHeader);                return format;            }                        return null;        }    }}import flash.utils.ByteArray;import flash.utils.Endian;import com.moorscode.sound.wave.PCMFormat;internal class SWFFormat {        /*    * *********************************************************    * CLASS PROPERTIES    * *********************************************************    *    */    private static const SWF_PART0:String = '46575309';    private static const SWF_PART1:String = '7800055F00000FA000000C01004411080000004302FFFFFFBF150B00000001005363656E6520310000BF14C7000000010000000010002E00000000080013574156506C61796572536F756E64436C6173730B666C6173682E6D6564696105536F756E64064F626A6563740C666C6173682E6576656E74730F4576656E744469737061746368657205160116031802160600050701020702040701050704070300000000000000000000000000010102080300010000000102010104010003000101050603D030470000010101060706D030D04900470000020201010517D0306500600330600430600230600258001D1D1D6801470000BF03';    private static const SWF_PART2:String = '3F131800000001000100574156506C61796572536F756E64436C61737300440B0800000040000000';        public static const CLASS_NAME:String = 'WAVPlayerSoundClass';        private var pcmFormat:PCMFormat;        /*    * *********************************************************    * CONSTRUCTOR    * *********************************************************    *    */    public function SWFFormat(format:PCMFormat) {        pcmFormat = format;    }        /*    * *********************************************************    * PRIVATE METHODS    * *********************************************************    *    */    private function writeBytesFromString(byteArray:ByteArray,bytesHexString:String):void {        var length:uint = bytesHexString.length;                for (var i:uint = 0;i<length;i+=2) {            var hexByte:String = bytesHexString.substr(i,2);            var byte:uint = Number('0x'+hexByte);            byteArray.writeByte(byte);        }    }        private function traceArray(array:ByteArray):String { // for debug        var out:String = '';        var pos:uint = array.position;        array.position = 0;                while (array.bytesAvailable) {            var str:String = array.readUnsignedByte().toString(16).toUpperCase();            str = str.length < 2 ? '0'+str : str;            out += str+' ';        }                array.position = pos;        return out;    }        private function getFormatByte():uint {        var byte:uint = (pcmFormat.bitsPerSample == 0x10) ? 0x32 : 0x00;        byte += (pcmFormat.channels-1);        byte += 4*(Math.floor(pcmFormat.sampleRate/5512.5).toString(2).length-1); // :-)        return byte;    }	    /*    * *********************************************************    * PUBLIC METHODS    * *********************************************************    *    */    public function compileSWF(audioData:ByteArray):ByteArray {        var dataLength:uint = audioData.length;        var swfSize:uint = dataLength+307;        var totalSamples:uint = dataLength/pcmFormat.blockAlign;        var output:ByteArray = new ByteArray();        output.endian = Endian.LITTLE_ENDIAN;        writeBytesFromString(output,SWFFormat.SWF_PART0);        output.writeUnsignedInt(swfSize);        writeBytesFromString(output,SWFFormat.SWF_PART1);        output.writeUnsignedInt(dataLength+7);        output.writeByte(1);        output.writeByte(0);        output.writeByte(getFormatByte());        output.writeUnsignedInt(totalSamples);        output.writeBytes(audioData);        writeBytesFromString(output,SWFFormat.SWF_PART2);        return output;    }}